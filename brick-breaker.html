<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Brick Breaker</title>
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self'">
  <meta name="referrer" content="strict-origin-when-cross-origin">
  <link rel="icon" href="favicon.svg" type="image/svg+xml">
  <link rel="stylesheet" href="css/theme.css">
  <style>
    body {
      overflow: hidden; width: 100vw; height: 100vh;
      background: #08090e;
      cursor: default;
    }

    canvas { display: block; }

    /* Rules dialog overlay */
    .rules-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      z-index: 20;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: default;
    }

    .rules-overlay.hidden { display: none; }

    .rules-dialog {
      background: var(--silver);
      border: 2px solid;
      border-color: var(--white) var(--dk-shadow) var(--dk-shadow) var(--white);
      box-shadow: inset 1px 1px 0 var(--silver), inset -1px -1px 0 var(--shadow);
      width: 340px;
      max-width: 90vw;
    }

    .rules-dialog .window-body { padding: 16px; line-height: 1.6; }

    .powerup-legend {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 4px 12px;
      margin-top: 8px;
      font-size: 12px;
    }

    .powerup-legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .powerup-swatch {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 13px;
      border-radius: 2px;
      color: #fff;
      font-size: 10px;
      font-weight: bold;
      flex-shrink: 0;
    }

    /* Game over overlay */
    .gameover-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      z-index: 20;
      display: none;
      align-items: center;
      justify-content: center;
      cursor: default;
    }

    .gameover-overlay.active { display: flex; }

    .gameover-dialog {
      background: var(--silver);
      border: 2px solid;
      border-color: var(--white) var(--dk-shadow) var(--dk-shadow) var(--white);
      box-shadow: inset 1px 1px 0 var(--silver), inset -1px -1px 0 var(--shadow);
      width: 280px;
      max-width: 90vw;
      text-align: center;
    }

    .gameover-dialog .window-body { padding: 20px; line-height: 1.6; }
    .gameover-dialog .final-score { font-size: 28px; font-weight: bold; margin: 8px 0; }
    .gameover-dialog .final-label { font-size: 13px; color: var(--dk-shadow); }
    .gameover-dialog .final-stats { font-size: 12px; color: var(--dk-shadow); margin-top: 4px; }
  </style>
</head>
<body>
  <div class="rules-overlay" id="rulesOverlay">
    <div class="rules-dialog">
      <div class="titlebar">
        <span>Brick Breaker</span>
      </div>
      <div class="window-body" id="rulesBody"></div>
    </div>
  </div>

  <canvas id="gameCanvas"></canvas>

  <div class="gameover-overlay" id="gameoverOverlay">
    <div class="gameover-dialog">
      <div class="titlebar">
        <span id="gameoverTitle">Game Over</span>
      </div>
      <div class="window-body">
        <div class="final-label" id="gameoverLabel">Final Score</div>
        <div class="final-score" id="finalScore">0</div>
        <div class="final-stats" id="finalStats"></div>
        <div class="button-row" style="margin-top:12px;justify-content:center;">
          <button class="btn" id="playAgainBtn">Play Again</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    /* ── Canvas setup ── */
    var canvas = document.getElementById("gameCanvas");
    var ctx = canvas.getContext("2d");

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resize);
    resize();

    /* ── DOM refs ── */
    var rulesOverlay = document.getElementById("rulesOverlay");
    var rulesBody = document.getElementById("rulesBody");
    var gameoverOverlay = document.getElementById("gameoverOverlay");
    var gameoverTitle = document.getElementById("gameoverTitle");
    var gameoverLabel = document.getElementById("gameoverLabel");
    var finalScoreEl = document.getElementById("finalScore");
    var finalStatsEl = document.getElementById("finalStats");

    /* ── Virtual coordinate system ── */
    var VW = 480;
    var VH = 640;

    function scaleX() { return canvas.width / VW; }
    function scaleY() { return canvas.height / VH; }

    /* ── Daily seed (same layout for everyone each day) ── */
    function todayKey() {
      var d = new Date();
      return d.getFullYear() + "-" + (d.getMonth() + 1) + "-" + d.getDate();
    }

    /* ── FNV-1a hash ── */
    function fnv(str) {
      var h = 0x811c9dc5;
      for (var i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 0x01000193);
      }
      return h >>> 0;
    }

    /* ── Mulberry32 PRNG ── */
    function mulberry32(seed) {
      var t = seed >>> 0;
      return function () {
        t += 0x6D2B79F5;
        var z = t;
        z = Math.imul(z ^ (z >>> 15), z | 1);
        z ^= z + Math.imul(z ^ (z >>> 7), z | 61);
        return ((z ^ (z >>> 14)) >>> 0) / 4294967296;
      };
    }

    /* ── Constants ── */
    var COLS = 10;
    var ROWS = 8;
    var BRICK_W = 44;
    var BRICK_H = 18;
    var BRICK_GAP_X = 4;
    var BRICK_GAP_Y = 3;
    var GRID_X = 2;
    var GRID_Y = 40;

    var PADDLE_W = 80;
    var PADDLE_H = 12;
    var PADDLE_Y = 600;
    var PADDLE_SPEED = 500;
    var PADDLE_W_MAX = 120;
    var PADDLE_W_GROW = 24;

    var BALL_R = 6;
    var BALL_INIT_SPEED = 300;
    var BALL_MAX_SPEED = 480;
    var BALL_SPEED_INC = 1.5;
    var MIN_BOUNCE_ANGLE = 20 * Math.PI / 180;

    var MAX_LIVES = 3;

    var POWERUP_W = 24;
    var POWERUP_H = 14;
    var POWERUP_FALL_SPEED = 150;
    var POWERUP_SPAWN_CHANCE = 0.12;
    var POWERUP_TIMER_DURATION = 8;

    var DANGER_LINE_Y = 560;

    /* ── 4-Color Palette (Cyan / Amber / Rose / Lime) ── */
    var COLORS = {
      cyan:   { highlight: "#85ccff", base: "#279ced", shadow: "#0f68a2" },
      amber:  { highlight: "#eabc6e", base: "#c68800", shadow: "#865900" },
      rose:   { highlight: "#ffa6ba", base: "#e16788", shadow: "#99415a" },
      lime:   { highlight: "#c8e688", base: "#7bb33a", shadow: "#4d7a1a" },
      violet: { highlight: "#c9a0dc", base: "#8e44ad", shadow: "#5b2c6f" }
    };
    var COLOR_KEYS = ["cyan", "amber", "rose", "lime", "violet"];

    /* Power-ups: 4 clean, understandable effects */
    var POWERUP_TYPES = [
      { type: "widen",     letter: "W", color: "#279ced", weight: 25 },
      { type: "multiball", letter: "M", color: "#7bb33a", weight: 25 },
      { type: "burner",    letter: "B", color: "#c68800", weight: 25 },
      { type: "freeze",    letter: "F", color: "#e16788", weight: 25 }
    ];

    var POWERUP_TOTAL_WEIGHT = 0;
    for (var pw = 0; pw < POWERUP_TYPES.length; pw++) {
      POWERUP_TOTAL_WEIGHT += POWERUP_TYPES[pw].weight;
    }

    /* ── Game state ── */
    var bricks = [];
    var paddleX = VW / 2;
    var paddleW = PADDLE_W;
    var balls = [];
    var score = 0;
    var lives = MAX_LIVES;
    var gameStarted = false;
    var gameOver = false;
    var powerups = [];

    var widenTimer = 0;
    var burnerTimer = 0;
    var freezeTimer = 0;

    var usePointer = true;
    var keys = {};

    /* Rising tide state */
    var riseTimer = 0;
    var riseInterval = 16;
    var elapsedTime = 0;
    var totalRowsSpawned = 0;
    var riseStartDelay = 15;
    var BRICK_SLIDE_SPEED = 120;
    var BRICK_GRAVITY_SPEED = 200;

    /* Chain state */
    var chainCounter = 0;
    var longestChain = 0;
    var chainTimer = 0;
    var CHAIN_TIMEOUT = 3.5;

    /* Rising projectile bricks */
    var risingBricks = [];
    var risingBrickTimer = 0;
    var RISING_BRICK_SPEED = 180;
    var RISING_BRICK_INTERVAL_MIN = 5;
    var RISING_BRICK_INTERVAL_MAX = 14;

    /* ── Juice: screen shake ── */
    var screenShake = 0;
    var shakeIntensity = 0;

    function triggerShake(intensity, duration) {
      if (intensity > shakeIntensity) {
        shakeIntensity = intensity;
        screenShake = duration;
      }
    }

    /* ── Juice: destruction particles ── */
    var particles = [];

    function spawnBrickParticles(brick) {
      var palette = COLORS[brick.colorKey] || COLORS.cyan;
      var cx = brick.x + brick.w / 2;
      var cy = brick.y + brick.h / 2;
      var count = 5 + Math.floor(Math.random() * 4);
      for (var p = 0; p < count; p++) {
        var angle = Math.random() * Math.PI * 2;
        var speed = 60 + Math.random() * 140;
        particles.push({
          x: cx + (Math.random() - 0.5) * brick.w * 0.6,
          y: cy + (Math.random() - 0.5) * brick.h * 0.6,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed - 50,
          size: 2 + Math.random() * 3,
          color: Math.random() < 0.5 ? palette.base : palette.highlight,
          life: 0.35 + Math.random() * 0.25,
          maxLife: 0
        });
        particles[particles.length - 1].maxLife = particles[particles.length - 1].life;
      }
    }

    /* ── Juice: floating score popups ── */
    var scorePopups = [];

    function spawnScorePopup(x, y, text, color) {
      scorePopups.push({
        x: x, y: y,
        text: text,
        color: color || "#fff",
        timer: 1.0,
        maxTimer: 1.0
      });
    }

    /* ── Daily seed ── */
    var dailySeed = fnv(todayKey());
    var rng;

    /* ── Ball helpers ── */
    function createBall(x, y, vx, vy, speed, attached) {
      return { x: x, y: y, vx: vx, vy: vy, speed: speed, attached: attached, burner: false };
    }

    function attachBall() {
      balls = [];
      var launchAngle = -90 + (Math.random() * 60 - 30);
      var rad = launchAngle * Math.PI / 180;
      var ball = createBall(
        paddleX,
        PADDLE_Y - BALL_R,
        Math.cos(rad) * BALL_INIT_SPEED,
        Math.sin(rad) * BALL_INIT_SPEED,
        BALL_INIT_SPEED,
        true
      );
      balls.push(ball);
    }

    function launchBalls() {
      if (gameOver) return;
      var launched = false;
      for (var i = 0; i < balls.length; i++) {
        if (balls[i].attached) {
          balls[i].attached = false;
          launched = true;
        }
      }
      return launched;
    }

    /* ── Brick helpers ── */
    function brickGridRow(brick) {
      var y = (brick.targetY !== undefined) ? brick.targetY : brick.y;
      return Math.round((y - GRID_Y) / (BRICK_H + BRICK_GAP_Y));
    }

    function brickGridCol(brick) {
      return Math.round((brick.x - GRID_X) / (BRICK_W + BRICK_GAP_X));
    }

    function findBrickAt(gridRow, gridCol) {
      for (var i = 0; i < bricks.length; i++) {
        if (!bricks[i].alive) continue;
        if (brickGridRow(bricks[i]) === gridRow && brickGridCol(bricks[i]) === gridCol) {
          return bricks[i];
        }
      }
      return null;
    }

    /* ── Brick generation ── */
    function generateBricks() {
      rng = mulberry32(dailySeed);
      bricks = [];

      for (var r = 0; r < ROWS; r++) {
        for (var c = 0; c < COLS; c++) {
          if (rng() > 0.75) continue;

          var typeRoll = rng();
          var type, hits, points;
          if (typeRoll < 0.08) {
            type = "bonus"; hits = 1; points = 50;
          } else if (typeRoll < 0.28) {
            type = "tough"; hits = 2; points = 25;
          } else {
            type = "normal"; hits = 1; points = 10;
          }

          var colorKey = COLOR_KEYS[Math.floor(rng() * COLOR_KEYS.length)];
          var bx = GRID_X + c * (BRICK_W + BRICK_GAP_X);
          var by = GRID_Y + r * (BRICK_H + BRICK_GAP_Y);

          bricks.push({
            x: bx, y: by, w: BRICK_W, h: BRICK_H,
            type: type, hits: hits, maxHits: hits, points: points,
            colorKey: colorKey, alive: true,
            flashTimer: 0
          });
        }
      }

      // Enforce minimum 20 bricks
      if (countAlive() < 20) {
        bricks = [];
        for (var r2 = 0; r2 < ROWS; r2++) {
          for (var c2 = 0; c2 < COLS; c2++) {
            if (rng() > 0.5) continue;
            var bx2 = GRID_X + c2 * (BRICK_W + BRICK_GAP_X);
            var by2 = GRID_Y + r2 * (BRICK_H + BRICK_GAP_Y);
            bricks.push({
              x: bx2, y: by2, w: BRICK_W, h: BRICK_H,
              type: "normal", hits: 1, maxHits: 1, points: 10,
              colorKey: COLOR_KEYS[Math.floor(rng() * COLOR_KEYS.length)],
              alive: true, flashTimer: 0
            });
          }
        }
      }

      if (countAlive() < 20) {
        bricks = [];
        for (var r3 = 0; r3 < ROWS; r3++) {
          for (var c3 = 0; c3 < COLS; c3++) {
            var bx3 = GRID_X + c3 * (BRICK_W + BRICK_GAP_X);
            var by3 = GRID_Y + r3 * (BRICK_H + BRICK_GAP_Y);
            bricks.push({
              x: bx3, y: by3, w: BRICK_W, h: BRICK_H,
              type: "normal", hits: 1, maxHits: 1, points: 10,
              colorKey: COLOR_KEYS[Math.floor(rng() * COLOR_KEYS.length)],
              alive: true, flashTimer: 0
            });
          }
        }
      }
    }

    function countAlive() {
      var c = 0;
      for (var i = 0; i < bricks.length; i++) {
        if (bricks[i].alive) c++;
      }
      return c;
    }

    /* ── Rising tide: spawn new row at top, push bricks down ── */
    function spawnRisingRow() {
      totalRowsSpawned++;
      var rowShift = BRICK_H + BRICK_GAP_Y;

      for (var i = 0; i < bricks.length; i++) {
        if (bricks[i].alive) {
          var currentTarget = (bricks[i].targetY !== undefined) ? bricks[i].targetY : bricks[i].y;
          bricks[i].targetY = currentTarget + rowShift;
        }
      }

      // Check danger line
      for (var j = 0; j < bricks.length; j++) {
        if (bricks[j].alive && bricks[j].targetY + bricks[j].h > DANGER_LINE_Y) {
          triggerGameOver();
          return;
        }
      }

      var newRowY = GRID_Y;
      var fillRate = Math.min(0.65, 0.4 + totalRowsSpawned * 0.005);
      var hasTough = (totalRowsSpawned % 5 === 0);
      var hasBonus = (totalRowsSpawned % 8 === 0);
      var toughCol = hasTough ? Math.floor(rng() * COLS) : -1;
      var bonusCol = hasBonus ? Math.floor(rng() * COLS) : -1;

      for (var c = 0; c < COLS; c++) {
        if (rng() > fillRate) continue;

        var type = "normal";
        var hits = 1;
        var points = 10;

        if (c === toughCol) {
          type = "tough"; hits = 2; points = 25;
        } else if (c === bonusCol) {
          type = "bonus"; hits = 1; points = 50;
        }

        var colorKey = COLOR_KEYS[Math.floor(rng() * COLOR_KEYS.length)];
        var bx = GRID_X + c * (BRICK_W + BRICK_GAP_X);

        bricks.push({
          x: bx, y: newRowY, w: BRICK_W, h: BRICK_H,
          type: type, hits: hits, maxHits: hits, points: points,
          colorKey: colorKey, alive: true,
          flashTimer: 0
        });
      }
    }

    /* ── Color chain: flood-fill same-color adjacency ── */
    function findConnectedGroup(brick) {
      var targetColor = brick.colorKey;
      var visited = {};
      var group = [];
      var startRow = brickGridRow(brick);
      var startCol = brickGridCol(brick);
      var queue = [{ r: startRow, c: startCol }];
      visited[startRow + "," + startCol] = true;

      while (queue.length > 0) {
        var pos = queue.shift();
        var found = findBrickAt(pos.r, pos.c);
        if (!found || !found.alive || found.colorKey !== targetColor) continue;
        group.push(found);

        var neighbors = [
          { r: pos.r - 1, c: pos.c },
          { r: pos.r + 1, c: pos.c },
          { r: pos.r, c: pos.c - 1 },
          { r: pos.r, c: pos.c + 1 }
        ];

        for (var n = 0; n < neighbors.length; n++) {
          var key = neighbors[n].r + "," + neighbors[n].c;
          if (!visited[key]) {
            visited[key] = true;
            queue.push(neighbors[n]);
          }
        }
      }

      return group;
    }

    /* ── Find all chain groups (3+ connected same-color) ── */
    function findAllChainGroups() {
      var visited = {};
      var groups = [];
      for (var i = 0; i < bricks.length; i++) {
        var b = bricks[i];
        if (!b.alive) continue;
        var key = brickGridRow(b) + "," + brickGridCol(b);
        if (visited[key]) continue;
        var group = findConnectedGroup(b);
        for (var g = 0; g < group.length; g++) {
          visited[brickGridRow(group[g]) + "," + brickGridCol(group[g])] = true;
        }
        if (group.length >= 3) groups.push(group);
      }
      return groups;
    }

    /* ── Gravity: drop bricks to fill column gaps (returns indices of moved bricks) ── */
    function runGravity() {
      var moved = [];
      var changed = true;
      var maxIter = bricks.length * 2 + 1;
      while (changed && maxIter-- > 0) {
        changed = false;
        for (var i = 0; i < bricks.length; i++) {
          var b = bricks[i];
          if (!b.alive) continue;
          var effectiveY = (b.targetY !== undefined) ? b.targetY : b.y;
          var row = Math.round((effectiveY - GRID_Y) / (BRICK_H + BRICK_GAP_Y));
          var col = brickGridCol(b);
          var belowRow = row + 1;
          var belowY = GRID_Y + belowRow * (BRICK_H + BRICK_GAP_Y);

          if (belowY > PADDLE_Y - PADDLE_H - BRICK_H) continue;

          var below = null;
          for (var j = 0; j < bricks.length; j++) {
            if (bricks[j].alive && bricks[j] !== b) {
              var ey = (bricks[j].targetY !== undefined) ? bricks[j].targetY : bricks[j].y;
              var bRow = Math.round((ey - GRID_Y) / (BRICK_H + BRICK_GAP_Y));
              if (bRow === belowRow && brickGridCol(bricks[j]) === col) {
                below = bricks[j];
                break;
              }
            }
          }
          if (!below) {
            var hasLower = false;
            for (var k = 0; k < bricks.length; k++) {
              if (bricks[k].alive && bricks[k] !== b) {
                var eyk = (bricks[k].targetY !== undefined) ? bricks[k].targetY : bricks[k].y;
                var kRow = Math.round((eyk - GRID_Y) / (BRICK_H + BRICK_GAP_Y));
                if (brickGridCol(bricks[k]) === col && kRow > row) {
                  hasLower = true;
                  break;
                }
              }
            }
            if (hasLower) {
              b.targetY = belowY;
              b.gravityDrop = true;
              if (moved.indexOf(i) === -1) moved.push(i);
              changed = true;
            }
          }
        }
      }
      return moved;
    }

    /* ── Cascade: clear chain groups triggered by moved/placed bricks (chain-reaction-style) ── */
    var _cascadeDepth = 0;
    function cascadeCheck(triggerIndices) {
      _cascadeDepth++;
      if (_cascadeDepth > 10) { _cascadeDepth--; return; }

      var triggerSet = {};
      for (var t = 0; t < triggerIndices.length; t++) {
        triggerSet[triggerIndices[t]] = true;
      }

      var chainGroups = findAllChainGroups();
      var clearedAny = false;

      for (var g = 0; g < chainGroups.length; g++) {
        var group = chainGroups[g];
        var hasTrigger = false;
        for (var j = 0; j < group.length; j++) {
          var idx = bricks.indexOf(group[j]);
          if (triggerSet[idx]) { hasTrigger = true; break; }
        }
        if (!hasTrigger) continue;

        clearedAny = true;
        chainCounter++;
        chainTimer = CHAIN_TIMEOUT;
        if (chainCounter > longestChain) longestChain = chainCounter;
        var mult = chainMultiplier(chainCounter);
        var cx = 0, cy = 0, totalPts = 0;
        for (var k = 0; k < group.length; k++) {
          var gb = group[k];
          gb.alive = false;
          gb.flashTimer = 0.15;
          var pts = gb.points * mult;
          score += pts;
          totalPts += pts;
          cx += gb.x + gb.w / 2;
          cy += gb.y + gb.h / 2;
          spawnBrickParticles(gb);
          trySpawnPowerup(gb.x + gb.w / 2, gb.y + gb.h / 2);
        }
        cx /= group.length;
        cy /= group.length;
        spawnScorePopup(cx, cy, "CHAIN x" + chainCounter + "  +" + totalPts, COLORS[group[0].colorKey].highlight);
        triggerShake(3 + chainCounter, 0.2);
      }

      if (clearedAny) {
        var moved = runGravity();
        if (moved.length > 0) {
          cascadeCheck(moved);
        }
      }

      _cascadeDepth--;
    }

    function chainMultiplier(chain) {
      if (chain <= 1) return 1;
      if (chain === 2) return 3;
      if (chain === 3) return 6;
      if (chain === 4) return 10;
      return 10 + (chain - 4) * 5;
    }

    /* ── Game over / reset ── */
    function triggerGameOver() {
      gameOver = true;
      triggerShake(8, 0.4);
      var minutes = Math.floor(elapsedTime / 60);
      var survivalBonus = 100 * minutes;
      score += survivalBonus;
      gameoverTitle.textContent = "Game Over";
      gameoverLabel.textContent = "Final Score";
      finalScoreEl.textContent = score;
      var survMin = Math.floor(elapsedTime / 60);
      var survSec = Math.floor(elapsedTime % 60);
      finalStatsEl.textContent = "Survived: " + survMin + "m " + survSec + "s" +
        (longestChain > 1 ? " \u00b7 Best chain: \u00d7" + longestChain : "");
      gameoverOverlay.classList.add("active");
    }

    function resetGame() {
      score = 0;
      lives = MAX_LIVES;
      gameOver = false;
      powerups = [];
      widenTimer = 0;
      burnerTimer = 0;
      freezeTimer = 0;
      paddleW = PADDLE_W;
      paddleX = VW / 2;
      riseTimer = 0;
      riseInterval = 16;
      elapsedTime = 0;
      totalRowsSpawned = 0;
      chainCounter = 0;
      longestChain = 0;
      chainTimer = 0;
      risingBricks = [];
      risingBrickTimer = RISING_BRICK_INTERVAL_MIN + Math.random() * (RISING_BRICK_INTERVAL_MAX - RISING_BRICK_INTERVAL_MIN);
      particles = [];
      scorePopups = [];
      screenShake = 0;
      shakeIntensity = 0;
      dailySeed = fnv(todayKey());
      generateBricks();
      attachBall();
      gameoverOverlay.classList.remove("active");
    }

    /* ── Power-up spawn (weighted) ── */
    function trySpawnPowerup(bx, by) {
      if (Math.random() >= POWERUP_SPAWN_CHANCE) return;
      var roll = Math.random() * POWERUP_TOTAL_WEIGHT;
      var accum = 0;
      var pick = POWERUP_TYPES[0];
      for (var i = 0; i < POWERUP_TYPES.length; i++) {
        accum += POWERUP_TYPES[i].weight;
        if (roll < accum) { pick = POWERUP_TYPES[i]; break; }
      }
      powerups.push({
        x: bx, y: by,
        type: pick.type,
        color: pick.color,
        letter: pick.letter
      });
    }

    function applyPowerup(pu) {
      if (pu.type === "widen") {
        paddleW = Math.min(PADDLE_W_MAX, PADDLE_W + PADDLE_W_GROW);
        widenTimer = POWERUP_TIMER_DURATION;
      } else if (pu.type === "multiball") {
        var src = null;
        for (var i = 0; i < balls.length; i++) {
          if (!balls[i].attached) { src = balls[i]; break; }
        }
        if (src) {
          var currentSpeed = Math.sqrt(src.vx * src.vx + src.vy * src.vy);
          if (currentSpeed === 0) currentSpeed = src.speed;
          var baseAngle = Math.atan2(src.vy, src.vx);
          var offset = 30 * Math.PI / 180;
          var b1 = createBall(src.x, src.y,
            Math.cos(baseAngle + offset) * currentSpeed,
            Math.sin(baseAngle + offset) * currentSpeed,
            src.speed, false);
          b1.burner = src.burner;
          var b2 = createBall(src.x, src.y,
            Math.cos(baseAngle - offset) * currentSpeed,
            Math.sin(baseAngle - offset) * currentSpeed,
            src.speed, false);
          b2.burner = src.burner;
          balls.push(b1);
          balls.push(b2);
        }
      } else if (pu.type === "burner") {
        burnerTimer = POWERUP_TIMER_DURATION;
        for (var j = 0; j < balls.length; j++) {
          balls[j].burner = true;
        }
      } else if (pu.type === "freeze") {
        freezeTimer = 15;
      }
    }

    /* ── Input handling ── */
    window.addEventListener("keydown", function (e) {
      if (e.key === "ArrowLeft" || e.key === "ArrowRight") {
        e.preventDefault();
        keys[e.key] = true;
        usePointer = false;
      }
      if (e.key === " " || e.key === "Spacebar") {
        e.preventDefault();
        if (gameStarted && !gameOver) {
          launchBalls();
        }
      }
    });

    window.addEventListener("keyup", function (e) {
      keys[e.key] = false;
    });

    window.addEventListener("pointermove", function (e) {
      if (!gameStarted || gameOver) return;
      usePointer = true;
      var sx = scaleX();
      paddleX = e.clientX / sx;
      paddleX = Math.max(paddleW / 2, Math.min(VW - paddleW / 2, paddleX));
    });

    window.addEventListener("touchmove", function (e) {
      if (!gameStarted || gameOver) return;
      e.preventDefault();
      usePointer = true;
      var sx = scaleX();
      paddleX = e.touches[0].clientX / sx;
      paddleX = Math.max(paddleW / 2, Math.min(VW - paddleW / 2, paddleX));
    }, { passive: false });

    canvas.addEventListener("pointerdown", function (e) {
      if (!gameStarted || gameOver) return;
      usePointer = true;
      var sx = scaleX();
      paddleX = e.clientX / sx;
      paddleX = Math.max(paddleW / 2, Math.min(VW - paddleW / 2, paddleX));
      launchBalls();
    });

    /* ── Collision: ball vs bricks ── */
    function ballBrickCollision(ball) {
      for (var i = 0; i < bricks.length; i++) {
        var b = bricks[i];
        if (!b.alive) continue;
        if (b.flashTimer > 0) continue;

        var closestX = Math.max(b.x, Math.min(ball.x, b.x + b.w));
        var closestY = Math.max(b.y, Math.min(ball.y, b.y + b.h));
        var dx = ball.x - closestX;
        var dy = ball.y - closestY;
        var distSq = dx * dx + dy * dy;

        if (distSq <= BALL_R * BALL_R) {
          if (!ball.burner) {
            var overlapLeft = (ball.x + BALL_R) - b.x;
            var overlapRight = (b.x + b.w) - (ball.x - BALL_R);
            var overlapTop = (ball.y + BALL_R) - b.y;
            var overlapBottom = (b.y + b.h) - (ball.y - BALL_R);
            var minOverlapX = Math.min(overlapLeft, overlapRight);
            var minOverlapY = Math.min(overlapTop, overlapBottom);

            if (Math.abs(minOverlapX - minOverlapY) < 1) {
              ball.vx = -ball.vx;
              ball.vy = -ball.vy;
            } else if (minOverlapX < minOverlapY) {
              ball.vx = -ball.vx;
            } else {
              ball.vy = -ball.vy;
            }

            // Push ball out of brick to prevent re-collision
            var sepDist = BALL_R - Math.sqrt(distSq) + 0.5;
            if (sepDist > 0 && distSq > 0) {
              var sepLen = Math.sqrt(distSq);
              ball.x += (dx / sepLen) * sepDist;
              ball.y += (dy / sepLen) * sepDist;
            } else if (distSq === 0) {
              if (minOverlapX < minOverlapY) {
                ball.x += (overlapLeft < overlapRight ? -1 : 1) * minOverlapX;
              } else {
                ball.y += (overlapTop < overlapBottom ? -1 : 1) * minOverlapY;
              }
            }
          }

          b.hits--;

          if (b.hits <= 0) {
            // Destroy single brick (chains come from gravity cascades, not direct hits)
            b.alive = false;
            score += b.points;
            spawnBrickParticles(b);
            spawnScorePopup(b.x + b.w / 2, b.y + b.h / 2, "+" + b.points);
            trySpawnPowerup(b.x + b.w / 2, b.y + b.h / 2);

            ball.speed = Math.min(BALL_MAX_SPEED, ball.speed + BALL_SPEED_INC);
            var currentSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
            if (currentSpeed > 0) {
              ball.vx = (ball.vx / currentSpeed) * ball.speed;
              ball.vy = (ball.vy / currentSpeed) * ball.speed;
            }

            // Gravity may trigger cascade chains (Puyo Puyo-style)
            var moved = runGravity();
            if (moved.length > 0) {
              cascadeCheck(moved);
            }
          } else {
            // Brick took a hit but didn't die (tough brick)
            triggerShake(1.5, 0.08);
          }

          if (!ball.burner) break;
        }
      }
    }

    /* ── Rendering ── */
    function drawBricks() {
      var sx = scaleX();
      var sy = scaleY();

      var chainGroups = findAllChainGroups();

      for (var i = 0; i < bricks.length; i++) {
        var b = bricks[i];
        if (!b.alive) continue;

        var rx = b.x * sx;
        var ry = b.y * sy;
        var rw = b.w * sx;
        var rh = b.h * sy;

        var palette = COLORS[b.colorKey];
        var baseColor = palette.base;
        var highlightColor = palette.highlight;
        var shadowColor = palette.shadow;

        if (b.flashTimer > 0) {
          baseColor = palette.shadow;
          highlightColor = palette.shadow;
          shadowColor = palette.highlight;
        }

        if (b.type === "tough" && b.hits < b.maxHits) {
          baseColor = shadowColor;
        }

        ctx.fillStyle = baseColor;
        ctx.fillRect(rx, ry, rw, rh);

        ctx.fillStyle = highlightColor;
        ctx.fillRect(rx, ry, rw, 1 * sy);

        ctx.fillStyle = shadowColor;
        ctx.fillRect(rx, ry + rh - 1 * sy, rw, 1 * sy);

        if (b.type === "tough" && b.hits < b.maxHits) {
          ctx.fillStyle = shadowColor;
          ctx.fillRect(rx + rw * 0.1, ry + rh * 0.45, rw * 0.8, 1);
        }

        if (b.type === "bonus") {
          var cx = rx + rw / 2;
          var cy = ry + rh / 2;
          var dSize = Math.min(rw, rh) * 0.3;
          ctx.strokeStyle = highlightColor;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(cx, cy - dSize);
          ctx.lineTo(cx + dSize, cy);
          ctx.lineTo(cx, cy + dSize);
          ctx.lineTo(cx - dSize, cy);
          ctx.closePath();
          ctx.stroke();
        }
      }

      // Chain outlines
      for (var ci = 0; ci < chainGroups.length; ci++) {
        var grp = chainGroups[ci];
        var palette2 = COLORS[grp[0].colorKey];
        ctx.strokeStyle = palette2.highlight;
        ctx.globalAlpha = 0.5 + 0.15 * Math.sin(elapsedTime * 4);
        ctx.lineWidth = 1.5;

        var inGroup = {};
        for (var cj = 0; cj < grp.length; cj++) {
          inGroup[brickGridRow(grp[cj]) + "," + brickGridCol(grp[cj])] = true;
        }

        for (var ck = 0; ck < grp.length; ck++) {
          var gb = grp[ck];
          var grx = gb.x * sx;
          var gry = gb.y * sy;
          var grw = gb.w * sx;
          var grh = gb.h * sy;
          var gr = brickGridRow(gb);
          var gc = brickGridCol(gb);

          ctx.beginPath();
          if (!inGroup[(gr - 1) + "," + gc]) {
            ctx.moveTo(grx, gry); ctx.lineTo(grx + grw, gry);
          }
          if (!inGroup[(gr + 1) + "," + gc]) {
            ctx.moveTo(grx, gry + grh); ctx.lineTo(grx + grw, gry + grh);
          }
          if (!inGroup[gr + "," + (gc - 1)]) {
            ctx.moveTo(grx, gry); ctx.lineTo(grx, gry + grh);
          }
          if (!inGroup[gr + "," + (gc + 1)]) {
            ctx.moveTo(grx + grw, gry); ctx.lineTo(grx + grw, gry + grh);
          }
          ctx.stroke();
        }
      }
      ctx.globalAlpha = 1;
    }

    function drawRisingBricks() {
      var sx = scaleX();
      var sy = scaleY();
      for (var i = 0; i < risingBricks.length; i++) {
        var rb = risingBricks[i];
        var rx = rb.x * sx;
        var ry = rb.y * sy;
        var rw = rb.w * sx;
        var rh = rb.h * sy;
        var palette = COLORS[rb.colorKey];

        ctx.fillStyle = palette.base;
        ctx.fillRect(rx, ry, rw, rh);
        ctx.fillStyle = palette.highlight;
        ctx.fillRect(rx, ry, rw, 1 * sy);
        ctx.fillStyle = palette.shadow;
        ctx.fillRect(rx, ry + rh - 1 * sy, rw, 1 * sy);

        // Arrow indicator
        var acx = rx + rw / 2;
        var acy = ry + rh / 2;
        var aSize = Math.min(rw, rh) * 0.25;
        ctx.strokeStyle = palette.highlight;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(acx - aSize, acy + aSize * 0.5);
        ctx.lineTo(acx, acy - aSize * 0.5);
        ctx.lineTo(acx + aSize, acy + aSize * 0.5);
        ctx.stroke();
      }
    }

    function drawDangerLine() {
      var sx = scaleX();
      var sy = scaleY();

      // Check if bricks are close to danger line for warning pulse
      var closestDist = DANGER_LINE_Y;
      for (var i = 0; i < bricks.length; i++) {
        if (!bricks[i].alive) continue;
        var by = (bricks[i].targetY !== undefined) ? bricks[i].targetY : bricks[i].y;
        var dist = DANGER_LINE_Y - (by + bricks[i].h);
        if (dist < closestDist) closestDist = dist;
      }

      var dangerAlpha = 0;
      if (closestDist < 80) {
        dangerAlpha = (1 - closestDist / 80) * (0.5 + 0.5 * Math.sin(elapsedTime * 6));
      }

      // Danger line
      ctx.fillStyle = "#99415a";
      ctx.fillRect(0, DANGER_LINE_Y * sy, canvas.width, 1);

      // Warning zone
      var warnAlpha = 0.06 + dangerAlpha * 0.12;
      ctx.fillStyle = "rgba(153,65,90," + warnAlpha + ")";
      ctx.fillRect(0, DANGER_LINE_Y * sy, canvas.width, (PADDLE_Y - DANGER_LINE_Y) * sy);

      // Edge pulse when danger is close
      if (dangerAlpha > 0.05) {
        ctx.fillStyle = "rgba(153,65,90," + (dangerAlpha * 0.15) + ")";
        ctx.fillRect(0, 0, 3 * sx, canvas.height);
        ctx.fillRect(canvas.width - 3 * sx, 0, 3 * sx, canvas.height);
      }
    }

    function drawPowerups() {
      var sx = scaleX();
      var sy = scaleY();
      for (var i = 0; i < powerups.length; i++) {
        var pu = powerups[i];
        var rw = POWERUP_W * sx;
        var rh = POWERUP_H * sy;
        var rx = pu.x * sx - rw / 2;
        var ry = pu.y * sy - rh / 2;

        ctx.fillStyle = pu.color;
        ctx.fillRect(rx, ry, rw, rh);

        ctx.fillStyle = "#fff";
        ctx.font = "bold " + Math.round(10 * Math.min(sx, sy)) + "px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(pu.letter, pu.x * sx, pu.y * sy);
      }
    }

    function drawPaddle() {
      var sx = scaleX();
      var sy = scaleY();
      var px = (paddleX - paddleW / 2) * sx;
      var py = PADDLE_Y * sy;
      var pw = paddleW * sx;
      var ph = PADDLE_H * sy;

      // Tint paddle based on active power-ups
      var faceColor = "#85ccff";
      var edgeColor = "#0f68a2";
      if (burnerTimer > 0) {
        faceColor = "#eabc6e";
        edgeColor = "#865900";
      } else if (widenTimer > 0) {
        faceColor = "#a8d8ff";
        edgeColor = "#279ced";
      }

      ctx.fillStyle = faceColor;
      ctx.fillRect(px, py, pw, ph);
      ctx.fillStyle = edgeColor;
      ctx.fillRect(px, py + ph - 2 * sy, pw, 2 * sy);
    }

    function drawBalls() {
      var sx = scaleX();
      var sy = scaleY();
      for (var i = 0; i < balls.length; i++) {
        var ball = balls[i];
        var bx = ball.x * sx;
        var by = ball.y * sy;
        var br = BALL_R * Math.min(sx, sy);

        var ballColor = ball.burner ? "#c68800" : "#f0f0f0";

        ctx.beginPath();
        ctx.arc(bx, by, br, 0, Math.PI * 2);
        ctx.fillStyle = ballColor;
        ctx.fill();

        // Burner trail
        if (ball.burner && !ball.attached) {
          ctx.beginPath();
          ctx.arc(bx - ball.vx * 0.008, by - ball.vy * 0.008, br * 0.8, 0, Math.PI * 2);
          ctx.fillStyle = "rgba(198,136,0,0.4)";
          ctx.fill();
          ctx.beginPath();
          ctx.arc(bx - ball.vx * 0.016, by - ball.vy * 0.016, br * 0.5, 0, Math.PI * 2);
          ctx.fillStyle = "rgba(198,136,0,0.2)";
          ctx.fill();
        }
      }
    }

    function drawParticles() {
      var sx = scaleX();
      var sy = scaleY();
      for (var i = 0; i < particles.length; i++) {
        var p = particles[i];
        var alpha = p.life / p.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        var ps = p.size * Math.min(sx, sy);
        ctx.fillRect(p.x * sx - ps / 2, p.y * sy - ps / 2, ps, ps);
      }
      ctx.globalAlpha = 1;
    }

    function drawScorePopups() {
      var sx = scaleX();
      var sy = scaleY();
      var fontSize = Math.round(11 * Math.min(sx, sy));
      ctx.font = "bold " + fontSize + "px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      for (var i = 0; i < scorePopups.length; i++) {
        var sp = scorePopups[i];
        var alpha = Math.min(1, sp.timer / (sp.maxTimer * 0.3));
        var rise = (1 - sp.timer / sp.maxTimer) * 30;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = sp.color;
        ctx.fillText(sp.text, sp.x * sx, (sp.y - rise) * sy);
      }
      ctx.globalAlpha = 1;
    }

    function drawHUD() {
      var sx = scaleX();
      var sy = scaleY();
      var fontSize = Math.round(13 * Math.min(sx, sy));

      // Score
      ctx.fillStyle = "#d0d4dc";
      ctx.font = "bold " + fontSize + "px sans-serif";
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      ctx.fillText("Score: " + score, 8 * sx, 10 * sy);

      // Chain multiplier
      if (chainCounter > 1 && chainTimer > 0) {
        var chainAlpha = Math.min(1, chainTimer / 1);
        ctx.globalAlpha = chainAlpha;
        ctx.fillStyle = "#eabc6e";
        ctx.fillText("\u00d7" + chainMultiplier(chainCounter) + " chain", 8 * sx, 26 * sy);
        ctx.globalAlpha = 1;
      }

      // Lives
      var dotR = 5 * Math.min(sx, sy);
      var dotSpacing = 16 * sx;
      var dotY = 18 * sy;
      var startDotX = canvas.width - 12 * sx;

      for (var i = MAX_LIVES - 1; i >= 0; i--) {
        var dotX = startDotX - (MAX_LIVES - 1 - i) * dotSpacing;
        ctx.beginPath();
        ctx.arc(dotX, dotY, dotR, 0, Math.PI * 2);
        ctx.fillStyle = i < lives ? "#279ced" : "rgba(39,156,237,0.25)";
        ctx.fill();
      }

      // Active power-up timer bars
      var barY = 32;
      var barH = 4;
      var barW = 48;
      var barX = canvas.width - 12 * sx - barW * sx;
      var smallFont = Math.round(9 * Math.min(sx, sy));
      ctx.font = "bold " + smallFont + "px sans-serif";
      ctx.textAlign = "right";
      ctx.textBaseline = "top";

      var timers = [];
      if (widenTimer > 0) timers.push({ label: "WIDE", frac: widenTimer / POWERUP_TIMER_DURATION, color: "#279ced" });
      if (burnerTimer > 0) timers.push({ label: "BURN", frac: burnerTimer / POWERUP_TIMER_DURATION, color: "#c68800" });
      if (freezeTimer > 0) timers.push({ label: "FREEZE", frac: freezeTimer / 15, color: "#e16788" });

      for (var ti = 0; ti < timers.length; ti++) {
        var t = timers[ti];
        var ty = (barY + ti * 12) * sy;

        ctx.fillStyle = "rgba(255,255,255,0.1)";
        ctx.fillRect(barX, ty, barW * sx, barH * sy);

        ctx.fillStyle = t.color;
        ctx.fillRect(barX, ty, barW * sx * t.frac, barH * sy);

        ctx.fillStyle = t.color;
        ctx.fillText(t.label, barX - 4 * sx, ty - 1 * sy);
      }
    }

    /* ── Game loop ── */
    var prev = 0;

    function loop(now) {
      var dt = Math.min((now - prev) / 1000, 0.05);
      prev = now;

      /* ── Update ── */
      if (gameStarted && !gameOver) {
        elapsedTime += dt;

        // Paddle movement (keyboard)
        if (!usePointer) {
          if (keys.ArrowLeft) paddleX -= PADDLE_SPEED * dt;
          if (keys.ArrowRight) paddleX += PADDLE_SPEED * dt;
        }
        paddleX = Math.max(paddleW / 2, Math.min(VW - paddleW / 2, paddleX));

        // Power-up timers
        if (widenTimer > 0) {
          widenTimer -= dt;
          if (widenTimer <= 0) {
            widenTimer = 0;
            paddleW = PADDLE_W;
          }
        }
        if (burnerTimer > 0) {
          burnerTimer -= dt;
          if (burnerTimer <= 0) {
            burnerTimer = 0;
            for (var bi = 0; bi < balls.length; bi++) {
              balls[bi].burner = false;
            }
          }
        }
        if (freezeTimer > 0) {
          freezeTimer -= dt;
          if (freezeTimer <= 0) freezeTimer = 0;
        }

        // Chain timeout
        if (chainTimer > 0) {
          chainTimer -= dt;
          if (chainTimer <= 0) {
            chainTimer = 0;
            chainCounter = 0;
          }
        }

        // Smooth brick slide toward targetY
        for (var si = 0; si < bricks.length; si++) {
          var sb = bricks[si];
          if (!sb.alive || sb.targetY === undefined) continue;
          if (sb.y < sb.targetY) {
            var speed = sb.gravityDrop ? BRICK_GRAVITY_SPEED : BRICK_SLIDE_SPEED;
            sb.y = Math.min(sb.targetY, sb.y + speed * dt);
            if (sb.y >= sb.targetY) {
              sb.y = sb.targetY;
              delete sb.targetY;
              delete sb.gravityDrop;
            }
          }
        }

        // Flash timers
        for (var fi = 0; fi < bricks.length; fi++) {
          if (bricks[fi].flashTimer > 0) {
            bricks[fi].flashTimer -= dt;
          }
        }

        // Rising tide (paused during freeze)
        if (elapsedTime > riseStartDelay && freezeTimer <= 0) {
          riseTimer += dt;
          riseInterval = Math.max(6, 16 - (elapsedTime / 60) * 0.8);
          if (riseTimer >= riseInterval) {
            riseTimer = 0;
            spawnRisingRow();
          }
        }

        // Update balls
        for (var i = balls.length - 1; i >= 0; i--) {
          var ball = balls[i];

          if (ball.attached) {
            ball.x = paddleX;
            ball.y = PADDLE_Y - BALL_R;
            continue;
          }

          // Move ball with substep subdivision to prevent tunneling
          var ballSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
          var stepDist = BALL_R;
          var totalDist = ballSpeed * dt;
          var numSteps = Math.max(1, Math.ceil(totalDist / stepDist));
          var subDt = dt / numSteps;

          for (var step = 0; step < numSteps; step++) {
            ball.x += ball.vx * subDt;
            ball.y += ball.vy * subDt;

            // Wall bounces
            if (ball.x - BALL_R <= 0) {
              ball.x = BALL_R;
              ball.vx = Math.abs(ball.vx);
            } else if (ball.x + BALL_R >= VW) {
              ball.x = VW - BALL_R;
              ball.vx = -Math.abs(ball.vx);
            }

            if (ball.y - BALL_R <= 0) {
              ball.y = BALL_R;
              ball.vy = Math.abs(ball.vy);
            }

            // Paddle collision
            if (ball.vy > 0 &&
                ball.y + BALL_R >= PADDLE_Y &&
                ball.y + BALL_R <= PADDLE_Y + PADDLE_H + ball.vy * subDt &&
                ball.x >= paddleX - paddleW / 2 &&
                ball.x <= paddleX + paddleW / 2) {

              ball.y = PADDLE_Y - BALL_R;

              var hitPos = (ball.x - (paddleX - paddleW / 2)) / paddleW;
              var centered = hitPos * 2 - 1;
              var angle = -90 + centered * (90 - MIN_BOUNCE_ANGLE * 180 / Math.PI);
              var rad = angle * Math.PI / 180;

              ball.vx = Math.cos(rad) * ball.speed;
              ball.vy = Math.sin(rad) * ball.speed;

              // Prevent perfectly vertical bounce
              var minVx = ball.speed * 0.08;
              if (Math.abs(ball.vx) < minVx) {
                ball.vx = (ball.vx >= 0 ? 1 : -1) * minVx;
                if (ball.vx === 0) ball.vx = (Math.random() < 0.5 ? -1 : 1) * minVx;
                var pSpd = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                ball.vx = (ball.vx / pSpd) * ball.speed;
                ball.vy = (ball.vy / pSpd) * ball.speed;
              }
              break;
            }

            // Brick collisions
            ballBrickCollision(ball);
          }

          // Ball out bottom
          if (ball.y > VH + BALL_R) {
            balls.splice(i, 1);
          }
        }

        // Life lost
        if (balls.length === 0 && !gameOver) {
          lives--;
          triggerShake(6, 0.25);
          if (lives <= 0) {
            triggerGameOver();
          } else {
            paddleW = PADDLE_W;
            widenTimer = 0;
            attachBall();
            // Partial speed reset on life loss for fair recovery
            for (var bl = 0; bl < balls.length; bl++) {
              balls[bl].speed = BALL_INIT_SPEED;
            }
          }
        }

        // Update power-ups (fall + catch)
        for (var pi = powerups.length - 1; pi >= 0; pi--) {
          var pu = powerups[pi];
          pu.y += POWERUP_FALL_SPEED * dt;

          if (pu.y + POWERUP_H / 2 >= PADDLE_Y &&
              pu.y - POWERUP_H / 2 <= PADDLE_Y + PADDLE_H &&
              pu.x + POWERUP_W / 2 >= paddleX - paddleW / 2 &&
              pu.x - POWERUP_W / 2 <= paddleX + paddleW / 2) {
            applyPowerup(pu);
            powerups.splice(pi, 1);
            continue;
          }

          if (pu.y > VH + POWERUP_H) {
            powerups.splice(pi, 1);
          }
        }

        // Spawn rising bricks (paused during freeze)
        if (elapsedTime > riseStartDelay && freezeTimer <= 0) {
          risingBrickTimer -= dt;
          if (risingBrickTimer <= 0) {
            risingBrickTimer = RISING_BRICK_INTERVAL_MIN + Math.random() * (RISING_BRICK_INTERVAL_MAX - RISING_BRICK_INTERVAL_MIN);
            var rbCol = Math.floor(Math.random() * COLS);
            var rbX = GRID_X + rbCol * (BRICK_W + BRICK_GAP_X);
            risingBricks.push({
              x: rbX, y: VH + BRICK_H,
              w: BRICK_W, h: BRICK_H,
              colorKey: COLOR_KEYS[Math.floor(Math.random() * COLOR_KEYS.length)],
              col: rbCol
            });
          }
        }

        // Update rising bricks (paused during freeze)
        for (var ri = risingBricks.length - 1; ri >= 0; ri--) {
          var rb = risingBricks[ri];
          if (rb.vy === undefined) rb.vy = -RISING_BRICK_SPEED;
          if (rb.vx === undefined) rb.vx = 0;

          if (freezeTimer <= 0) {
            rb.y += rb.vy * dt;
            rb.x += rb.vx * dt;
          }

          // Horizontal bounds (account for brick width)
          if (rb.x < GRID_X) { rb.x = GRID_X; rb.vx = Math.abs(rb.vx) * 0.5; }
          var maxRbX = GRID_X + (COLS - 1) * (BRICK_W + BRICK_GAP_X);
          if (rb.x + rb.w > maxRbX + BRICK_W) { rb.x = maxRbX; rb.vx = -Math.abs(rb.vx) * 0.5; }

          // Ball collision — deflect
          var rbDeflected = false;
          for (var rbi = 0; rbi < balls.length; rbi++) {
            var rball = balls[rbi];
            if (rball.attached) continue;
            var rcx = Math.max(rb.x, Math.min(rball.x, rb.x + rb.w));
            var rcy = Math.max(rb.y, Math.min(rball.y, rb.y + rb.h));
            var rdx = rball.x - rcx;
            var rdy = rball.y - rcy;
            if (rdx * rdx + rdy * rdy <= BALL_R * BALL_R) {
              if (!rball.burner) rball.vy = -rball.vy;
              rb.vy = -RISING_BRICK_SPEED * 1.5;
              rb.vx = (rb.x + rb.w / 2 - rball.x) * 3;
              var rbMaxSpd = RISING_BRICK_SPEED * 1.8;
              var rbSpd = Math.sqrt(rb.vx * rb.vx + rb.vy * rb.vy);
              if (rbSpd > rbMaxSpd) {
                rb.vx = (rb.vx / rbSpd) * rbMaxSpd;
                rb.vy = (rb.vy / rbSpd) * rbMaxSpd;
              }
              rb.deflected = true;
              rbDeflected = true;
              break;
            }
          }

          // Paddle collision — deflect with aim
          if (!rbDeflected && !rb.deflected &&
              rb.y + rb.h >= PADDLE_Y &&
              rb.y <= PADDLE_Y + PADDLE_H &&
              rb.x + rb.w >= paddleX - paddleW / 2 &&
              rb.x <= paddleX + paddleW / 2) {
            var rbHitPos = (rb.x + rb.w / 2 - paddleX) / (paddleW / 2);
            rb.vy = -RISING_BRICK_SPEED * 1.8;
            rb.vx = rbHitPos * 200;
            var rbPMaxSpd = RISING_BRICK_SPEED * 2;
            var rbPSpd = Math.sqrt(rb.vx * rb.vx + rb.vy * rb.vy);
            if (rbPSpd > rbPMaxSpd) {
              rb.vx = (rb.vx / rbPSpd) * rbPMaxSpd;
              rb.vy = (rb.vy / rbPSpd) * rbPMaxSpd;
            }
            rb.deflected = true;
          }

          // Settle deflected bricks into grid
          if (rb.vy < 0 && rb.deflected) {
            var rbCenterX = rb.x + rb.w / 2;
            var nearestCol = Math.round((rbCenterX - GRID_X - BRICK_W / 2) / (BRICK_W + BRICK_GAP_X));
            nearestCol = Math.max(0, Math.min(COLS - 1, nearestCol));

            var lowestOccupied = -1;
            for (var li = 0; li < bricks.length; li++) {
              if (!bricks[li].alive) continue;
              if (brickGridCol(bricks[li]) !== nearestCol) continue;
              var bRow = brickGridRow(bricks[li]);
              if (bRow > lowestOccupied) lowestOccupied = bRow;
            }

            var settleRow = (lowestOccupied >= 0) ? lowestOccupied + 1 : 0;
            var settleY = GRID_Y + settleRow * (BRICK_H + BRICK_GAP_Y);

            if (rb.y <= settleY && settleY < PADDLE_Y - PADDLE_H - BRICK_H) {
              var snapX = GRID_X + nearestCol * (BRICK_W + BRICK_GAP_X);
              bricks.push({
                x: snapX, y: settleY, w: BRICK_W, h: BRICK_H,
                type: "normal", hits: 1, maxHits: 1, points: 10,
                colorKey: rb.colorKey, alive: true, flashTimer: 0
              });
              risingBricks.splice(ri, 1);

              // Placed brick may trigger cascade chains
              cascadeCheck([bricks.length - 1]);
              continue;
            }
          }

          // Non-deflected bricks settle normally
          if (!rb.deflected) {
            var nCenterX = rb.x + rb.w / 2;
            var nCol = Math.round((nCenterX - GRID_X - BRICK_W / 2) / (BRICK_W + BRICK_GAP_X));
            nCol = Math.max(0, Math.min(COLS - 1, nCol));
            rb.col = nCol;

            var bottomBrickY = -1;
            for (var nli = 0; nli < bricks.length; nli++) {
              if (!bricks[nli].alive) continue;
              if (brickGridCol(bricks[nli]) !== nCol) continue;
              if (bricks[nli].y > bottomBrickY) bottomBrickY = bricks[nli].y;
            }

            var nSettleY = -1;
            if (bottomBrickY >= 0) {
              var nTarget = bottomBrickY + BRICK_H + BRICK_GAP_Y;
              if (rb.y <= nTarget) nSettleY = nTarget;
            } else if (rb.y <= GRID_Y) {
              nSettleY = GRID_Y;
            }

            if (nSettleY >= 0 && nSettleY < PADDLE_Y - PADDLE_H - BRICK_H) {
              var nSnapX = GRID_X + nCol * (BRICK_W + BRICK_GAP_X);
              bricks.push({
                x: nSnapX, y: nSettleY, w: BRICK_W, h: BRICK_H,
                type: "normal", hits: 1, maxHits: 1, points: 10,
                colorKey: rb.colorKey, alive: true, flashTimer: 0
              });
              risingBricks.splice(ri, 1);

              // Placed brick may trigger cascade chains
              cascadeCheck([bricks.length - 1]);
              continue;
            }
          }

          // Off screen — remove
          if (rb.y + rb.h < -50 || rb.y > VH + 50) {
            risingBricks.splice(ri, 1);
          }
        }

        // Update particles
        for (var pi2 = particles.length - 1; pi2 >= 0; pi2--) {
          var part = particles[pi2];
          part.x += part.vx * dt;
          part.y += part.vy * dt;
          part.vy += 300 * dt; // gravity
          part.life -= dt;
          if (part.life <= 0) {
            particles.splice(pi2, 1);
          }
        }

        // Update score popups
        for (var spi = scorePopups.length - 1; spi >= 0; spi--) {
          scorePopups[spi].timer -= dt;
          if (scorePopups[spi].timer <= 0) {
            scorePopups.splice(spi, 1);
          }
        }

        // Update screen shake
        if (screenShake > 0) {
          screenShake -= dt;
          if (screenShake <= 0) {
            screenShake = 0;
            shakeIntensity = 0;
          }
        }
      }

      /* ── Render ── */
      ctx.fillStyle = "#08090e";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (gameStarted) {
        // Apply screen shake
        var shakeOffX = 0;
        var shakeOffY = 0;
        if (screenShake > 0) {
          var shakePow = shakeIntensity * (screenShake / 0.3);
          shakeOffX = (Math.random() - 0.5) * shakePow * 2;
          shakeOffY = (Math.random() - 0.5) * shakePow * 2;
          ctx.save();
          ctx.translate(shakeOffX, shakeOffY);
        }

        drawDangerLine();
        drawBricks();
        drawRisingBricks();
        drawPowerups();
        drawPaddle();
        drawBalls();
        drawParticles();
        drawScorePopups();
        drawHUD();

        if (screenShake > 0) {
          ctx.restore();
        }
      }

      requestAnimationFrame(loop);
    }

    /* ── Build rules dialog ── */
    function buildRulesDialog() {
      var isDesktop = window.matchMedia("(hover:hover) and (pointer:fine)").matches;

      var html = "";
      if (isDesktop) {
        html += "<div><strong>Mouse:</strong> Move paddle</div>";
        html += "<div><strong>Click / Space:</strong> Launch ball</div>";
      } else {
        html += "<div><strong>Drag:</strong> Move paddle</div>";
        html += "<div><strong>Tap:</strong> Launch ball</div>";
      }

      html += '<div style="margin-top:10px;font-size:12px;"><strong>How to play</strong></div>';
      html += '<div style="font-size:12px;">Break bricks with the ball. When a brick is destroyed, bricks above it fall. If falling bricks form groups of <strong>3+ same-color</strong>, they <strong>cascade-clear</strong> for big points! Chain multiple cascades for huge multipliers.</div>';
      html += '<div style="font-size:12px;margin-top:4px;">New rows push down from above. Don\u2019t let them reach the red line! Loose bricks rise from below \u2014 <strong>deflect them into matching colors</strong> to trigger chains.</div>';

      html += '<div style="margin-top:8px;font-size:12px;"><strong>Power-ups</strong></div>';
      html += '<div class="powerup-legend">';
      html += '<div class="powerup-legend-item"><span class="powerup-swatch" style="background:#279ced">W</span> Widen</div>';
      html += '<div class="powerup-legend-item"><span class="powerup-swatch" style="background:#7bb33a">M</span> Multiball</div>';
      html += '<div class="powerup-legend-item"><span class="powerup-swatch" style="background:#c68800">B</span> Burner</div>';
      html += '<div class="powerup-legend-item"><span class="powerup-swatch" style="background:#e16788">F</span> Freeze</div>';
      html += '</div>';

      html += '<div class="button-row" style="margin-top:12px">';
      html += '<button class="btn" id="startBtn">Play</button>';
      html += '</div>';

      rulesBody.innerHTML = html;

      document.getElementById("startBtn").addEventListener("click", function () {
        rulesOverlay.classList.add("hidden");
        gameStarted = true;
      });
    }

    /* ── UI buttons ── */
    document.getElementById("playAgainBtn").addEventListener("click", function () {
      resetGame();
    });

    /* ── Initialize ── */
    buildRulesDialog();
    generateBricks();
    attachBall();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
