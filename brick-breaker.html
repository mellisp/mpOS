<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Brick Breaker</title>
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self'">
  <meta name="referrer" content="strict-origin-when-cross-origin">
  <link rel="icon" href="favicon.svg" type="image/svg+xml">
  <link rel="stylesheet" href="css/theme.css">
  <style>
    body {
      overflow: hidden; width: 100vw; height: 100vh;
      background: #08090e;
      cursor: default;
    }

    canvas { display: block; }

    /* Rules dialog overlay */
    .rules-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      z-index: 20;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: default;
    }

    .rules-overlay.hidden { display: none; }

    .rules-dialog {
      background: var(--silver);
      border: 2px solid;
      border-color: var(--white) var(--dk-shadow) var(--dk-shadow) var(--white);
      box-shadow: inset 1px 1px 0 var(--silver), inset -1px -1px 0 var(--shadow);
      width: 340px;
      max-width: 90vw;
    }

    .rules-dialog .window-body { padding: 16px; line-height: 1.6; }

    .powerup-legend {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 4px 12px;
      margin-top: 8px;
      font-size: 12px;
    }

    .powerup-legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .powerup-swatch {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 13px;
      border-radius: 2px;
      color: #fff;
      font-size: 10px;
      font-weight: bold;
      flex-shrink: 0;
    }

    /* Game over overlay */
    .gameover-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      z-index: 20;
      display: none;
      align-items: center;
      justify-content: center;
      cursor: default;
    }

    .gameover-overlay.active { display: flex; }

    .gameover-dialog {
      background: var(--silver);
      border: 2px solid;
      border-color: var(--white) var(--dk-shadow) var(--dk-shadow) var(--white);
      box-shadow: inset 1px 1px 0 var(--silver), inset -1px -1px 0 var(--shadow);
      width: 280px;
      max-width: 90vw;
      text-align: center;
    }

    .gameover-dialog .window-body { padding: 20px; line-height: 1.6; }
    .gameover-dialog .final-score { font-size: 28px; font-weight: bold; margin: 8px 0; }
    .gameover-dialog .final-label { font-size: 13px; color: var(--dk-shadow); }
    .gameover-dialog .final-stats { font-size: 12px; color: var(--dk-shadow); margin-top: 4px; }
  </style>
</head>
<body>
  <div class="rules-overlay" id="rulesOverlay">
    <div class="rules-dialog">
      <div class="titlebar">
        <span>Brick Breaker</span>
      </div>
      <div class="window-body" id="rulesBody"></div>
    </div>
  </div>

  <canvas id="gameCanvas"></canvas>

  <div class="gameover-overlay" id="gameoverOverlay">
    <div class="gameover-dialog">
      <div class="titlebar">
        <span id="gameoverTitle">Game Over</span>
      </div>
      <div class="window-body">
        <div class="final-label" id="gameoverLabel">Final Score</div>
        <div class="final-score" id="finalScore">0</div>
        <div class="final-stats" id="finalStats"></div>
        <div class="button-row" style="margin-top:12px;justify-content:center;">
          <button class="btn" id="playAgainBtn">Play Again</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    /* ── Canvas setup ── */
    var canvas = document.getElementById("gameCanvas");
    var ctx = canvas.getContext("2d");

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resize);
    resize();

    /* ── DOM refs ── */
    var rulesOverlay = document.getElementById("rulesOverlay");
    var rulesBody = document.getElementById("rulesBody");
    var gameoverOverlay = document.getElementById("gameoverOverlay");
    var gameoverTitle = document.getElementById("gameoverTitle");
    var gameoverLabel = document.getElementById("gameoverLabel");
    var finalScoreEl = document.getElementById("finalScore");
    var finalStatsEl = document.getElementById("finalStats");

    /* ── Virtual coordinate system ── */
    var VW = 480;
    var VH = 640;

    function scaleX() { return canvas.width / VW; }
    function scaleY() { return canvas.height / VH; }

    /* ── Daily seed (same layout for everyone each day, replayable) ── */
    function todayKey() {
      var d = new Date();
      return d.getFullYear() + "-" + (d.getMonth() + 1) + "-" + d.getDate();
    }

    /* ── FNV-1a hash ── */
    function fnv(str) {
      var h = 0x811c9dc5;
      for (var i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 0x01000193);
      }
      return h >>> 0;
    }

    /* ── Mulberry32 PRNG ── */
    function mulberry32(seed) {
      var t = seed >>> 0;
      return function () {
        t += 0x6D2B79F5;
        var z = t;
        z = Math.imul(z ^ (z >>> 15), z | 1);
        z ^= z + Math.imul(z ^ (z >>> 7), z | 61);
        return ((z ^ (z >>> 14)) >>> 0) / 4294967296;
      };
    }

    /* ── Constants ── */
    var COLS = 10;
    var ROWS = 8;
    var BRICK_W = 44;
    var BRICK_H = 18;
    var BRICK_GAP_X = 4;
    var BRICK_GAP_Y = 3;
    var GRID_X = 2;
    var GRID_Y = 40;

    var PADDLE_W = 80;
    var PADDLE_H = 12;
    var PADDLE_Y = 600;
    var PADDLE_SPEED = 500;
    var PADDLE_W_MIN = 40;
    var PADDLE_W_MAX = 120;
    var PADDLE_W_GROW = 24;
    var PADDLE_W_SHRINK = 20;

    var BALL_R = 6;
    var BALL_INIT_SPEED = 300;
    var BALL_MAX_SPEED = 480;
    var BALL_SPEED_INC = 1.5;
    var MIN_BOUNCE_ANGLE = 20 * Math.PI / 180;

    var MAX_LIVES = 3;

    var POWERUP_W = 24;
    var POWERUP_H = 14;
    var POWERUP_FALL_SPEED = 150;
    var POWERUP_SPAWN_CHANCE = 0.12;
    var POWERUP_TIMER_DURATION = 8;

    var HAZARD_CHANCE = 0.07;
    var HAZARD_FALL_SPEED = 200;

    var DANGER_LINE_Y = 560;
    var DEBRIS_FILL_THRESHOLD = 25;

    /* ── 4-Color Palette (Cyan / Amber / Rose / Lime) ── */
    var COLORS = {
      cyan:  { highlight: "#85ccff", base: "#279ced", shadow: "#0f68a2" },
      amber: { highlight: "#eabc6e", base: "#c68800", shadow: "#865900" },
      rose:  { highlight: "#ffa6ba", base: "#e16788", shadow: "#99415a" },
      lime:  { highlight: "#c8e688", base: "#7bb33a", shadow: "#4d7a1a" }
    };
    var COLOR_KEYS = ["cyan", "amber", "rose", "lime"];

    var POWERUP_TYPES = [
      { type: "widen",     letter: "W", color: "#279ced", weight: 20 },
      { type: "multiball", letter: "M", color: "#279ced", weight: 15 },
      { type: "burner",    letter: "B", color: "#c68800", weight: 15 },
      { type: "blast",     letter: "X", color: "#c68800", weight: 10 },
      { type: "freeze",    letter: "F", color: "#e16788", weight: 15 },
      { type: "magnetize", letter: "G", color: "#e16788", weight: 10 },
      { type: "shrink",    letter: "S", color: "#404040", weight: 15 }
    ];

    var POWERUP_TOTAL_WEIGHT = 0;
    for (var pw = 0; pw < POWERUP_TYPES.length; pw++) {
      POWERUP_TOTAL_WEIGHT += POWERUP_TYPES[pw].weight;
    }

    /* ── Game state ── */
    var bricks = [];
    var paddleX = VW / 2;
    var paddleW = PADDLE_W;
    var balls = [];
    var score = 0;
    var lives = MAX_LIVES;
    var gameStarted = false;
    var gameOver = false;

    var powerups = [];
    var fallingHazards = [];

    var widenTimer = 0;
    var shrinkTimer = 0;
    var burnerTimer = 0;
    var freezeTimer = 0;
    var magnetizeTimer = 0;

    var usePointer = true;
    var keys = {};

    /* Rising tide state */
    var riseTimer = 0;
    var riseInterval = 12;
    var elapsedTime = 0;
    var totalRowsSpawned = 0;
    var riseStartDelay = 10;
    var BRICK_SLIDE_SPEED = 120; /* pixels per second for smooth slide */

    /* Cascade state */
    var cascadePending = [];
    var cascadeDelay = 0;
    var chainCounter = 0;
    var longestChain = 0;

    /* Combo streak */
    var comboStreak = 0;

    /* Debris meter */
    var debrisMeter = 0;
    var debrisParticles = [];

    /* Wave clear flash effect */
    var waveClearFlash = 0;

    /* Rising projectile bricks */
    var risingBricks = [];
    var risingBrickTimer = 0;
    var RISING_BRICK_SPEED = 180;
    var RISING_BRICK_INTERVAL_MIN = 6;
    var RISING_BRICK_INTERVAL_MAX = 14;

    /* Last hit brick position (for Blast) */
    var lastHitBrickCol = -1;
    var lastHitBrickRow = -1;

    /* ── Daily seed ── */
    var dailySeed = fnv(todayKey());
    var rng;

    /* ── Ball helpers ── */
    function createBall(x, y, vx, vy, speed, attached) {
      return { x: x, y: y, vx: vx, vy: vy, speed: speed, attached: attached, burner: false };
    }

    function attachBall() {
      balls = [];
      var launchAngle = -90 + (Math.random() * 60 - 30);
      var rad = launchAngle * Math.PI / 180;
      var ball = createBall(
        paddleX,
        PADDLE_Y - BALL_R,
        Math.cos(rad) * BALL_INIT_SPEED,
        Math.sin(rad) * BALL_INIT_SPEED,
        BALL_INIT_SPEED,
        true
      );
      balls.push(ball);
    }

    function launchBalls() {
      if (gameOver) return;
      var launched = false;
      for (var i = 0; i < balls.length; i++) {
        if (balls[i].attached) {
          balls[i].attached = false;
          launched = true;
        }
      }
      return launched;
    }

    /* ── Brick helpers ── */
    function brickGridRow(brick) {
      var y = (brick.targetY !== undefined) ? brick.targetY : brick.y;
      return Math.round((y - GRID_Y) / (BRICK_H + BRICK_GAP_Y));
    }

    function brickGridCol(brick) {
      return Math.round((brick.x - GRID_X) / (BRICK_W + BRICK_GAP_X));
    }

    function findBrickAt(gridRow, gridCol) {
      for (var i = 0; i < bricks.length; i++) {
        if (!bricks[i].alive) continue;
        if (brickGridRow(bricks[i]) === gridRow && brickGridCol(bricks[i]) === gridCol) {
          return bricks[i];
        }
      }
      return null;
    }

    /* ── Brick generation ── */
    function generateBricks() {
      rng = mulberry32(dailySeed);
      bricks = [];

      for (var r = 0; r < ROWS; r++) {
        for (var c = 0; c < COLS; c++) {
          if (rng() > 0.75) continue;

          var typeRoll = rng();
          var type, hits, points;
          if (typeRoll < 0.08) {
            type = "bonus"; hits = 1; points = 50;
          } else if (typeRoll < 0.28) {
            type = "tough"; hits = 2; points = 25;
          } else {
            type = "normal"; hits = 1; points = 10;
          }

          var hazard = rng() < HAZARD_CHANCE;
          var colorKey = COLOR_KEYS[Math.floor(rng() * COLOR_KEYS.length)];

          var bx = GRID_X + c * (BRICK_W + BRICK_GAP_X);
          var by = GRID_Y + r * (BRICK_H + BRICK_GAP_Y);

          bricks.push({
            x: bx, y: by, w: BRICK_W, h: BRICK_H,
            type: type, hits: hits, maxHits: hits, points: points,
            colorKey: colorKey, alive: true, hazard: hazard,
            flashTimer: 0
          });
        }
      }

      // Enforce minimum 20 bricks
      if (countAlive() < 20) {
        bricks = [];
        for (var r2 = 0; r2 < ROWS; r2++) {
          for (var c2 = 0; c2 < COLS; c2++) {
            if (rng() > 0.5) continue;
            var bx2 = GRID_X + c2 * (BRICK_W + BRICK_GAP_X);
            var by2 = GRID_Y + r2 * (BRICK_H + BRICK_GAP_Y);
            bricks.push({
              x: bx2, y: by2, w: BRICK_W, h: BRICK_H,
              type: "normal", hits: 1, maxHits: 1, points: 10,
              colorKey: COLOR_KEYS[Math.floor(rng() * COLOR_KEYS.length)],
              alive: true, hazard: rng() < HAZARD_CHANCE,
              flashTimer: 0
            });
          }
        }
      }

      if (countAlive() < 20) {
        bricks = [];
        for (var r3 = 0; r3 < ROWS; r3++) {
          for (var c3 = 0; c3 < COLS; c3++) {
            var bx3 = GRID_X + c3 * (BRICK_W + BRICK_GAP_X);
            var by3 = GRID_Y + r3 * (BRICK_H + BRICK_GAP_Y);
            bricks.push({
              x: bx3, y: by3, w: BRICK_W, h: BRICK_H,
              type: "normal", hits: 1, maxHits: 1, points: 10,
              colorKey: COLOR_KEYS[Math.floor(rng() * COLOR_KEYS.length)],
              alive: true, hazard: rng() < HAZARD_CHANCE,
              flashTimer: 0
            });
          }
        }
      }
    }

    function countAlive() {
      var c = 0;
      for (var i = 0; i < bricks.length; i++) {
        if (bricks[i].alive) c++;
      }
      return c;
    }

    /* ── Rising tide: spawn new row at top, push bricks down ── */
    function spawnRisingRow() {
      totalRowsSpawned++;
      var rowShift = BRICK_H + BRICK_GAP_Y;

      // Set target positions — bricks will slide smoothly
      for (var i = 0; i < bricks.length; i++) {
        if (bricks[i].alive) {
          var currentTarget = (bricks[i].targetY !== undefined) ? bricks[i].targetY : bricks[i].y;
          bricks[i].targetY = currentTarget + rowShift;
        }
      }

      // Check danger line using target positions
      for (var j = 0; j < bricks.length; j++) {
        if (bricks[j].alive && bricks[j].targetY + bricks[j].h > DANGER_LINE_Y) {
          triggerGameOver();
          return;
        }
      }

      // Generate new row at the top
      var newRowY = GRID_Y;

      // Fill rate increases over time: 40% -> 65%
      var fillRate = Math.min(0.65, 0.4 + totalRowsSpawned * 0.005);
      var hasTough = (totalRowsSpawned % 5 === 0);
      var hasBonus = (totalRowsSpawned % 8 === 0);
      var toughCol = hasTough ? Math.floor(rng() * COLS) : -1;
      var bonusCol = hasBonus ? Math.floor(rng() * COLS) : -1;

      for (var c = 0; c < COLS; c++) {
        if (rng() > fillRate) continue;

        var type = "normal";
        var hits = 1;
        var points = 10;

        if (c === toughCol) {
          type = "tough"; hits = 2; points = 25;
        } else if (c === bonusCol) {
          type = "bonus"; hits = 1; points = 50;
        }

        var colorKey = COLOR_KEYS[Math.floor(rng() * COLOR_KEYS.length)];
        var bx = GRID_X + c * (BRICK_W + BRICK_GAP_X);

        bricks.push({
          x: bx, y: newRowY, w: BRICK_W, h: BRICK_H,
          type: type, hits: hits, maxHits: hits, points: points,
          colorKey: colorKey, alive: true,
          hazard: rng() < HAZARD_CHANCE,
          flashTimer: 0
        });
      }
    }

    /* ── Cascade system: flood-fill same-color adjacency ── */
    function findConnectedGroup(brick) {
      var targetColor = brick.colorKey;
      var visited = {};
      var group = [];
      var startRow = brickGridRow(brick);
      var startCol = brickGridCol(brick);
      var queue = [{ r: startRow, c: startCol }];
      visited[startRow + "," + startCol] = true;

      while (queue.length > 0) {
        var pos = queue.shift();
        var found = findBrickAt(pos.r, pos.c);
        if (!found || !found.alive || found.colorKey !== targetColor) continue;
        group.push(found);

        var neighbors = [
          { r: pos.r - 1, c: pos.c },
          { r: pos.r + 1, c: pos.c },
          { r: pos.r, c: pos.c - 1 },
          { r: pos.r, c: pos.c + 1 }
        ];

        for (var n = 0; n < neighbors.length; n++) {
          var key = neighbors[n].r + "," + neighbors[n].c;
          if (!visited[key]) {
            visited[key] = true;
            queue.push(neighbors[n]);
          }
        }
      }

      return group;
    }

    function triggerCascade(destroyedBrick) {
      var targetColor = destroyedBrick.colorKey;
      var startRow = brickGridRow(destroyedBrick);
      var startCol = brickGridCol(destroyedBrick);
      var alreadyQueued = {};

      // Check each neighbor of the destroyed brick
      var neighbors = [
        { r: startRow - 1, c: startCol },
        { r: startRow + 1, c: startCol },
        { r: startRow, c: startCol - 1 },
        { r: startRow, c: startCol + 1 }
      ];

      for (var n = 0; n < neighbors.length; n++) {
        var nb = findBrickAt(neighbors[n].r, neighbors[n].c);
        if (!nb || !nb.alive || nb.colorKey !== targetColor) continue;

        var nKey = brickGridRow(nb) + "," + brickGridCol(nb);
        if (alreadyQueued[nKey]) continue;

        var group = findConnectedGroup(nb);
        if (group.length >= 3) {
          chainCounter++;
          if (chainCounter > longestChain) longestChain = chainCounter;
          for (var j = 0; j < group.length; j++) {
            var gKey = brickGridRow(group[j]) + "," + brickGridCol(group[j]);
            alreadyQueued[gKey] = true;
            group[j].flashTimer = 0.2;
            cascadePending.push(group[j]);
          }
          cascadeDelay = 0.2;
        }
      }
    }

    function processCascadePending() {
      var triggeredNew = false;
      for (var i = cascadePending.length - 1; i >= 0; i--) {
        var b = cascadePending[i];
        if (b.alive) {
          b.alive = false;
          var mult = chainMultiplier(chainCounter);
          score += b.points * mult;
          addDebris(b);

          if (b.hazard) {
            fallingHazards.push({
              x: b.x, y: b.y, w: b.w, h: b.h,
              colorKey: b.colorKey
            });
          }

          trySpawnPowerup(b.x + b.w / 2, b.y + b.h / 2);
        }
      }
      cascadePending = [];

      // Gravity settle
      applyGravity();

      // Check for new cascades from settled bricks
      var checked = {};
      for (var j = 0; j < bricks.length; j++) {
        var brick = bricks[j];
        if (!brick.alive) continue;
        var gr = brickGridRow(brick);
        var gc = brickGridCol(brick);
        var key = gr + "," + gc;
        if (checked[key]) continue;
        checked[key] = true;

        var group = findConnectedGroup(brick);
        if (group.length >= 3) {
          chainCounter++;
          if (chainCounter > longestChain) longestChain = chainCounter;
          for (var k = 0; k < group.length; k++) {
            group[k].flashTimer = 0.2;
            cascadePending.push(group[k]);
          }
          triggeredNew = true;
        }
      }

      if (triggeredNew) {
        cascadeDelay = 0.2;
      }
    }

    function applyGravity() {
      // Find the lowest occupied row per column, then settle gaps
      var changed = true;
      while (changed) {
        changed = false;
        for (var i = 0; i < bricks.length; i++) {
          var b = bricks[i];
          if (!b.alive) continue;
          var row = brickGridRow(b);
          var col = brickGridCol(b);
          var belowRow = row + 1;
          var belowY = GRID_Y + belowRow * (BRICK_H + BRICK_GAP_Y);

          // Don't fall below the play area
          if (belowY > PADDLE_Y - PADDLE_H - BRICK_H) continue;

          // Check if there's a brick below
          var below = findBrickAt(belowRow, col);
          if (!below) {
            // Check if there's any alive brick at a lower row in this column
            var hasLower = false;
            for (var j = 0; j < bricks.length; j++) {
              if (bricks[j].alive && brickGridCol(bricks[j]) === col && brickGridRow(bricks[j]) > row) {
                hasLower = true;
                break;
              }
            }
            if (hasLower) {
              // Move this brick down one row
              b.y = belowY;
              changed = true;
            }
          }
        }
      }
    }

    function chainMultiplier(chain) {
      if (chain <= 1) return 1;
      if (chain === 2) return 3;
      if (chain === 3) return 6;
      if (chain === 4) return 10;
      return 10 + (chain - 4) * 5;
    }

    /* ── Game over / reset ── */
    function triggerGameOver() {
      gameOver = true;
      var minutes = Math.floor(elapsedTime / 60);
      var survivalBonus = 100 * minutes;
      score += survivalBonus;
      gameoverTitle.textContent = "Game Over";
      gameoverLabel.textContent = "Final Score";
      finalScoreEl.textContent = score;
      var survMin = Math.floor(elapsedTime / 60);
      var survSec = Math.floor(elapsedTime % 60);
      finalStatsEl.textContent = "Survived: " + survMin + "m " + survSec + "s" +
        (longestChain > 1 ? " \u00b7 Longest chain: \u00d7" + longestChain : "");
      gameoverOverlay.classList.add("active");
    }

    function resetGame() {
      score = 0;
      lives = MAX_LIVES;
      gameOver = false;
      powerups = [];
      fallingHazards = [];
      widenTimer = 0;
      shrinkTimer = 0;
      burnerTimer = 0;
      freezeTimer = 0;
      magnetizeTimer = 0;
      paddleW = PADDLE_W;
      paddleX = VW / 2;
      riseTimer = 0;
      riseInterval = 12;
      elapsedTime = 0;
      totalRowsSpawned = 0;
      cascadePending = [];
      cascadeDelay = 0;
      chainCounter = 0;
      longestChain = 0;
      comboStreak = 0;
      debrisMeter = 0;
      debrisParticles = [];
      waveClearFlash = 0;
      risingBricks = [];
      risingBrickTimer = RISING_BRICK_INTERVAL_MIN + Math.random() * (RISING_BRICK_INTERVAL_MAX - RISING_BRICK_INTERVAL_MIN);
      lastHitBrickCol = -1;
      lastHitBrickRow = -1;
      dailySeed = fnv(todayKey());
      generateBricks();
      attachBall();
      gameoverOverlay.classList.remove("active");
    }

    /* ── Power-up spawn (weighted) ── */
    function trySpawnPowerup(bx, by) {
      if (Math.random() >= POWERUP_SPAWN_CHANCE) return;
      var roll = Math.random() * POWERUP_TOTAL_WEIGHT;
      var accum = 0;
      var pick = POWERUP_TYPES[0];
      for (var i = 0; i < POWERUP_TYPES.length; i++) {
        accum += POWERUP_TYPES[i].weight;
        if (roll < accum) { pick = POWERUP_TYPES[i]; break; }
      }
      powerups.push({
        x: bx, y: by,
        type: pick.type,
        color: pick.color,
        letter: pick.letter
      });
    }

    function applyPowerup(pu) {
      if (pu.type === "widen") {
        paddleW = Math.min(PADDLE_W_MAX, paddleW + PADDLE_W_GROW);
        widenTimer = POWERUP_TIMER_DURATION;
        shrinkTimer = 0;
      } else if (pu.type === "shrink") {
        paddleW = Math.max(PADDLE_W_MIN, paddleW - PADDLE_W_SHRINK);
        shrinkTimer = POWERUP_TIMER_DURATION;
        widenTimer = 0;
      } else if (pu.type === "multiball") {
        var src = null;
        for (var i = 0; i < balls.length; i++) {
          if (!balls[i].attached) { src = balls[i]; break; }
        }
        if (src) {
          var currentSpeed = Math.sqrt(src.vx * src.vx + src.vy * src.vy);
          if (currentSpeed === 0) currentSpeed = src.speed;
          var baseAngle = Math.atan2(src.vy, src.vx);
          var offset = 30 * Math.PI / 180;
          var b1 = createBall(src.x, src.y,
            Math.cos(baseAngle + offset) * currentSpeed,
            Math.sin(baseAngle + offset) * currentSpeed,
            src.speed, false);
          b1.burner = src.burner;
          var b2 = createBall(src.x, src.y,
            Math.cos(baseAngle - offset) * currentSpeed,
            Math.sin(baseAngle - offset) * currentSpeed,
            src.speed, false);
          b2.burner = src.burner;
          balls.push(b1);
          balls.push(b2);
        }
      } else if (pu.type === "burner") {
        burnerTimer = POWERUP_TIMER_DURATION;
        for (var j = 0; j < balls.length; j++) {
          balls[j].burner = true;
        }
      } else if (pu.type === "blast") {
        // Destroy 3x3 area around last-hit brick
        if (lastHitBrickRow >= 0 && lastHitBrickCol >= 0) {
          var destroyed = [];
          for (var bi = 0; bi < bricks.length; bi++) {
            var brick = bricks[bi];
            if (!brick.alive) continue;
            var gr = brickGridRow(brick);
            var gc = brickGridCol(brick);
            if (Math.abs(gr - lastHitBrickRow) <= 1 && Math.abs(gc - lastHitBrickCol) <= 1) {
              destroyed.push(brick);
            }
          }
          chainCounter = 1;
          for (var bd = 0; bd < destroyed.length; bd++) {
            var db = destroyed[bd];
            db.alive = false;
            score += db.points;
            addDebris(db);
            if (db.hazard) {
              fallingHazards.push({ x: db.x, y: db.y, w: db.w, h: db.h, colorKey: db.colorKey });
            }
          }
          // Trigger cascades from blast
          applyGravity();
          var checked = {};
          for (var bj = 0; bj < bricks.length; bj++) {
            var cb = bricks[bj];
            if (!cb.alive) continue;
            var cbr = brickGridRow(cb);
            var cbc = brickGridCol(cb);
            var ck = cbr + "," + cbc;
            if (checked[ck]) continue;
            checked[ck] = true;
            var group = findConnectedGroup(cb);
            if (group.length >= 3) {
              chainCounter++;
              if (chainCounter > longestChain) longestChain = chainCounter;
              for (var gk = 0; gk < group.length; gk++) {
                group[gk].flashTimer = 0.2;
                cascadePending.push(group[gk]);
              }
              cascadeDelay = 0.2;
            }
          }
        }
      } else if (pu.type === "freeze") {
        freezeTimer = 15;
      } else if (pu.type === "magnetize") {
        magnetizeTimer = POWERUP_TIMER_DURATION;
      }
    }

    /* ── Debris junk pile ── */
    function addDebris(brick) {
      debrisMeter = Math.min(DEBRIS_FILL_THRESHOLD, debrisMeter + 1);
      var palette = COLORS[brick.colorKey] || COLORS.cyan;
      // Spawn 2-3 junk fragments that fall to the bottom
      var count = 2 + Math.floor(Math.random() * 2);
      for (var dp = 0; dp < count; dp++) {
        debrisParticles.push({
          x: brick.x + (brick.w || BRICK_W) * Math.random(),
          y: brick.y + (brick.h || BRICK_H) * Math.random(),
          targetY: VH - 2 - Math.random() * 14,
          w: 4 + Math.random() * 6,
          h: 3 + Math.random() * 4,
          color: palette.base,
          highlight: palette.highlight,
          settled: false
        });
      }
    }

    /* ── Wave Clear (debris meter) ── */
    function activateWaveClear() {
      if (debrisMeter < DEBRIS_FILL_THRESHOLD) return;
      debrisMeter = 0;
      debrisParticles = [];
      waveClearFlash = 0.35;

      // Find the bottommost row of alive bricks
      var maxRow = -1;
      for (var i = 0; i < bricks.length; i++) {
        if (!bricks[i].alive) continue;
        var r = brickGridRow(bricks[i]);
        if (r > maxRow) maxRow = r;
      }

      if (maxRow < 0) return;

      chainCounter = 1;
      var waveTargets = [];
      for (var j = 0; j < bricks.length; j++) {
        var b = bricks[j];
        if (!b.alive) continue;
        if (brickGridRow(b) === maxRow) {
          b.flashTimer = 0.25;
          waveTargets.push(b);
        }
      }

      // Queue them for delayed destruction via cascade system
      for (var wt = 0; wt < waveTargets.length; wt++) {
        cascadePending.push(waveTargets[wt]);
      }
      if (waveTargets.length > 0) cascadeDelay = 0.25;

      score += 100 * waveTargets.length;

      // Trigger cascade after wave clear (will run after delay)
      applyGravity();
      var checked = {};
      for (var k = 0; k < bricks.length; k++) {
        var cb = bricks[k];
        if (!cb.alive) continue;
        var gr = brickGridRow(cb);
        var gc = brickGridCol(cb);
        var key = gr + "," + gc;
        if (checked[key]) continue;
        checked[key] = true;
        var group = findConnectedGroup(cb);
        if (group.length >= 3) {
          chainCounter++;
          if (chainCounter > longestChain) longestChain = chainCounter;
          for (var gk = 0; gk < group.length; gk++) {
            group[gk].flashTimer = 0.2;
            cascadePending.push(group[gk]);
          }
          cascadeDelay = 0.2;
        }
      }
    }

    /* ── Input handling ── */
    window.addEventListener("keydown", function (e) {
      if (e.key === "ArrowLeft" || e.key === "ArrowRight") {
        e.preventDefault();
        keys[e.key] = true;
        usePointer = false;
      }
      if (e.key === " " || e.key === "Spacebar" || e.key === "d" || e.key === "D") {
        e.preventDefault();
        if (gameStarted && !gameOver) {
          if (debrisMeter >= DEBRIS_FILL_THRESHOLD) {
            activateWaveClear();
          } else {
            launchBalls();
          }
        }
      }
    });

    window.addEventListener("keyup", function (e) {
      keys[e.key] = false;
    });

    window.addEventListener("pointermove", function (e) {
      if (!gameStarted || gameOver) return;
      usePointer = true;
      var sx = scaleX();
      paddleX = e.clientX / sx;
      paddleX = Math.max(paddleW / 2, Math.min(VW - paddleW / 2, paddleX));
    });

    window.addEventListener("touchmove", function (e) {
      if (!gameStarted || gameOver) return;
      e.preventDefault();
      usePointer = true;
      var sx = scaleX();
      paddleX = e.touches[0].clientX / sx;
      paddleX = Math.max(paddleW / 2, Math.min(VW - paddleW / 2, paddleX));
    }, { passive: false });

    canvas.addEventListener("pointerdown", function (e) {
      if (!gameStarted || gameOver) return;
      usePointer = true;
      var sx = scaleX();
      paddleX = e.clientX / sx;
      paddleX = Math.max(paddleW / 2, Math.min(VW - paddleW / 2, paddleX));
      if (debrisMeter >= DEBRIS_FILL_THRESHOLD) {
        activateWaveClear();
      } else {
        launchBalls();
      }
    });

    // Swipe up on mobile to fire wave clear
    var touchStartY = 0;
    var touchStartTime = 0;
    canvas.addEventListener("touchstart", function (e) {
      if (!gameStarted || gameOver) return;
      touchStartY = e.touches[0].clientY;
      touchStartTime = Date.now();
    }, { passive: true });

    canvas.addEventListener("touchend", function (e) {
      if (!gameStarted || gameOver) return;
      var touchEndY = e.changedTouches[0].clientY;
      var dy = touchStartY - touchEndY;
      var elapsed = Date.now() - touchStartTime;
      // Swipe up: at least 50px upward within 400ms
      if (dy > 50 && elapsed < 400 && debrisMeter >= DEBRIS_FILL_THRESHOLD) {
        activateWaveClear();
      }
    }, { passive: true });

    /* ── Collision: ball vs bricks ── */
    function ballBrickCollision(ball) {
      for (var i = 0; i < bricks.length; i++) {
        var b = bricks[i];
        if (!b.alive) continue;
        if (b.flashTimer > 0) continue; // Being cascade-destroyed

        var closestX = Math.max(b.x, Math.min(ball.x, b.x + b.w));
        var closestY = Math.max(b.y, Math.min(ball.y, b.y + b.h));
        var dx = ball.x - closestX;
        var dy = ball.y - closestY;
        var distSq = dx * dx + dy * dy;

        if (distSq <= BALL_R * BALL_R) {
          if (!ball.burner) {
            var overlapLeft = (ball.x + BALL_R) - b.x;
            var overlapRight = (b.x + b.w) - (ball.x - BALL_R);
            var overlapTop = (ball.y + BALL_R) - b.y;
            var overlapBottom = (b.y + b.h) - (ball.y - BALL_R);
            var minOverlapX = Math.min(overlapLeft, overlapRight);
            var minOverlapY = Math.min(overlapTop, overlapBottom);

            if (Math.abs(minOverlapX - minOverlapY) < 1) {
              ball.vx = -ball.vx;
              ball.vy = -ball.vy;
            } else if (minOverlapX < minOverlapY) {
              ball.vx = -ball.vx;
            } else {
              ball.vy = -ball.vy;
            }
          }

          // Combo streak bonus
          var comboBonus = comboStreak * 5;
          comboStreak++;

          b.hits--;
          lastHitBrickRow = brickGridRow(b);
          lastHitBrickCol = brickGridCol(b);

          if (b.hits <= 0) {
            b.alive = false;
            var mult = chainMultiplier(1);
            score += b.points * mult + comboBonus;
            addDebris(b);
            ball.speed = Math.min(BALL_MAX_SPEED, ball.speed + BALL_SPEED_INC);

            var currentSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
            if (currentSpeed > 0) {
              ball.vx = (ball.vx / currentSpeed) * ball.speed;
              ball.vy = (ball.vy / currentSpeed) * ball.speed;
            }

            trySpawnPowerup(b.x + b.w / 2, b.y + b.h / 2);

            if (b.hazard) {
              fallingHazards.push({
                x: b.x, y: b.y, w: b.w, h: b.h, colorKey: b.colorKey
              });
            }

            // Settle bricks, then check for cascades
            applyGravity();
            chainCounter = 1;
            triggerCascade(b);
          }

          if (!ball.burner) break;
        }
      }
    }

    /* ── Rendering ── */
    function drawBricks() {
      var sx = scaleX();
      var sy = scaleY();

      for (var i = 0; i < bricks.length; i++) {
        var b = bricks[i];
        if (!b.alive) continue;

        var rx = b.x * sx;
        var ry = b.y * sy;
        var rw = b.w * sx;
        var rh = b.h * sy;

        var palette = COLORS[b.colorKey];
        var baseColor = palette.base;
        var highlightColor = palette.highlight;
        var shadowColor = palette.shadow;

        // Flash inversion during cascade
        if (b.flashTimer > 0) {
          baseColor = palette.shadow;
          highlightColor = palette.shadow;
          shadowColor = palette.highlight;
        }

        if (b.type === "tough" && b.hits < b.maxHits) {
          baseColor = shadowColor;
        }

        // Brick face
        ctx.fillStyle = baseColor;
        ctx.fillRect(rx, ry, rw, rh);

        // Top highlight (1px)
        ctx.fillStyle = highlightColor;
        ctx.fillRect(rx, ry, rw, 1 * sy);

        // Bottom shadow (1px)
        ctx.fillStyle = shadowColor;
        ctx.fillRect(rx, ry + rh - 1 * sy, rw, 1 * sy);

        // Tough brick with crack line after first hit
        if (b.type === "tough" && b.hits < b.maxHits) {
          ctx.fillStyle = shadowColor;
          ctx.fillRect(rx + rw * 0.1, ry + rh * 0.45, rw * 0.8, 1);
        }

        // Bonus brick: diamond outline
        if (b.type === "bonus") {
          var cx = rx + rw / 2;
          var cy = ry + rh / 2;
          var dSize = Math.min(rw, rh) * 0.3;
          ctx.strokeStyle = highlightColor;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(cx, cy - dSize);
          ctx.lineTo(cx + dSize, cy);
          ctx.lineTo(cx, cy + dSize);
          ctx.lineTo(cx - dSize, cy);
          ctx.closePath();
          ctx.stroke();
        }

        // Hazard brick: X marker
        if (b.hazard) {
          ctx.strokeStyle = shadowColor;
          ctx.lineWidth = 1.5;
          var xPad = rw * 0.3;
          var yPad = rh * 0.2;
          ctx.beginPath();
          ctx.moveTo(rx + xPad, ry + yPad);
          ctx.lineTo(rx + rw - xPad, ry + rh - yPad);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(rx + rw - xPad, ry + yPad);
          ctx.lineTo(rx + xPad, ry + rh - yPad);
          ctx.stroke();
        }
      }
    }

    function drawDebrisJunk() {
      var sx = scaleX();
      var sy = scaleY();
      var isFull = debrisMeter >= DEBRIS_FILL_THRESHOLD;
      var pulse = isFull ? (0.7 + 0.3 * Math.sin(elapsedTime * 5)) : 1;

      for (var i = 0; i < debrisParticles.length; i++) {
        var dp = debrisParticles[i];
        var rx = dp.x * sx;
        var ry = dp.y * sy;
        var rw = dp.w * sx;
        var rh = dp.h * sy;

        ctx.fillStyle = dp.settled && isFull ? dp.highlight : dp.color;
        ctx.globalAlpha = pulse;
        ctx.fillRect(rx, ry, rw, rh);
      }
      ctx.globalAlpha = 1;
    }

    function drawRisingBricks() {
      var sx = scaleX();
      var sy = scaleY();
      for (var i = 0; i < risingBricks.length; i++) {
        var rb = risingBricks[i];
        var rx = rb.x * sx;
        var ry = rb.y * sy;
        var rw = rb.w * sx;
        var rh = rb.h * sy;
        var palette = COLORS[rb.colorKey];

        // Brick face
        ctx.fillStyle = palette.base;
        ctx.fillRect(rx, ry, rw, rh);
        // Top highlight
        ctx.fillStyle = palette.highlight;
        ctx.fillRect(rx, ry, rw, 1 * sy);
        // Bottom shadow
        ctx.fillStyle = palette.shadow;
        ctx.fillRect(rx, ry + rh - 1 * sy, rw, 1 * sy);

        // Upward arrow indicator
        var cx = rx + rw / 2;
        var cy = ry + rh / 2;
        var aSize = Math.min(rw, rh) * 0.25;
        ctx.strokeStyle = palette.highlight;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(cx - aSize, cy + aSize * 0.5);
        ctx.lineTo(cx, cy - aSize * 0.5);
        ctx.lineTo(cx + aSize, cy + aSize * 0.5);
        ctx.stroke();
      }
    }

    function drawDangerLine() {
      var sx = scaleX();
      var sy = scaleY();
      ctx.fillStyle = "#99415a";
      ctx.fillRect(0, DANGER_LINE_Y * sy, canvas.width, 1);
      // Subtle warning zone above danger line
      ctx.fillStyle = "rgba(153,65,90,0.08)";
      ctx.fillRect(0, DANGER_LINE_Y * sy, canvas.width, (PADDLE_Y - DANGER_LINE_Y) * sy);
    }

    function drawFallingHazards() {
      var sx = scaleX();
      var sy = scaleY();
      for (var i = 0; i < fallingHazards.length; i++) {
        var h = fallingHazards[i];
        var rx = h.x * sx;
        var ry = h.y * sy;
        var rw = h.w * sx;
        var rh = h.h * sy;

        ctx.globalAlpha = 0.6;
        var palette = COLORS[h.colorKey] || COLORS.cyan;
        ctx.fillStyle = palette.base;
        ctx.fillRect(rx, ry, rw, rh);

        // Red X
        ctx.strokeStyle = "#c04040";
        ctx.lineWidth = 2;
        var xPad = rw * 0.25;
        var yPad = rh * 0.15;
        ctx.beginPath();
        ctx.moveTo(rx + xPad, ry + yPad);
        ctx.lineTo(rx + rw - xPad, ry + rh - yPad);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(rx + rw - xPad, ry + yPad);
        ctx.lineTo(rx + xPad, ry + rh - yPad);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
    }

    function drawPowerups() {
      var sx = scaleX();
      var sy = scaleY();
      for (var i = 0; i < powerups.length; i++) {
        var pu = powerups[i];
        var rw = POWERUP_W * sx;
        var rh = POWERUP_H * sy;
        var rx = pu.x * sx - rw / 2;
        var ry = pu.y * sy - rh / 2;

        // Flat rectangle
        ctx.fillStyle = pu.color;
        ctx.fillRect(rx, ry, rw, rh);

        // Letter
        ctx.fillStyle = "#fff";
        ctx.font = "bold " + Math.round(10 * Math.min(sx, sy)) + "px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(pu.letter, pu.x * sx, pu.y * sy);
      }
    }

    function drawPaddle() {
      var sx = scaleX();
      var sy = scaleY();
      var px = (paddleX - paddleW / 2) * sx;
      var py = PADDLE_Y * sy;
      var pw = paddleW * sx;
      var ph = PADDLE_H * sy;

      // Paddle face (cyan highlight)
      ctx.fillStyle = "#85ccff";
      ctx.fillRect(px, py, pw, ph);

      // Bottom edge (cyan shadow, 2px)
      ctx.fillStyle = "#0f68a2";
      ctx.fillRect(px, py + ph - 2 * sy, pw, 2 * sy);
    }

    function drawBalls() {
      var sx = scaleX();
      var sy = scaleY();
      for (var i = 0; i < balls.length; i++) {
        var ball = balls[i];
        var bx = ball.x * sx;
        var by = ball.y * sy;
        var br = BALL_R * Math.min(sx, sy);

        var ballColor = ball.burner ? "#c68800" : "#f0f0f0";

        // Solid circle, no glow
        ctx.beginPath();
        ctx.arc(bx, by, br, 0, Math.PI * 2);
        ctx.fillStyle = ballColor;
        ctx.fill();
      }
    }

    function drawHUD() {
      var sx = scaleX();
      var sy = scaleY();
      var fontSize = Math.round(13 * Math.min(sx, sy));

      // Score — left side
      ctx.fillStyle = "#d0d4dc";
      ctx.font = "bold " + fontSize + "px sans-serif";
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      ctx.fillText("Score: " + score, 8 * sx, 10 * sy);

      // Chain multiplier (if active)
      if (chainCounter > 1) {
        ctx.fillText("\u00d7" + chainMultiplier(chainCounter), 8 * sx, 26 * sy);
      }

      // Lives — right side as dots
      var dotR = 5 * Math.min(sx, sy);
      var dotSpacing = 16 * sx;
      var dotY = 18 * sy;
      var startDotX = canvas.width - 12 * sx;

      for (var i = MAX_LIVES - 1; i >= 0; i--) {
        var dotX = startDotX - (MAX_LIVES - 1 - i) * dotSpacing;
        ctx.beginPath();
        ctx.arc(dotX, dotY, dotR, 0, Math.PI * 2);
        if (i < lives) {
          ctx.fillStyle = "#279ced";
        } else {
          ctx.fillStyle = "rgba(39,156,237,0.25)";
        }
        ctx.fill();
      }

      // Freeze indicator
      if (freezeTimer > 0) {
        ctx.fillStyle = "#e16788";
        ctx.textAlign = "right";
        ctx.fillText("FREEZE " + Math.ceil(freezeTimer) + "s", canvas.width - 12 * sx, 30 * sy);
      }

      // "FIRE" label when debris pile is full
      if (debrisMeter >= DEBRIS_FILL_THRESHOLD) {
        var pulse = 0.6 + 0.4 * Math.sin(elapsedTime * 4);
        var smallFont = Math.round(10 * Math.min(sx, sy));
        ctx.fillStyle = "rgba(133,204,255," + pulse + ")";
        ctx.font = "bold " + smallFont + "px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "bottom";
        ctx.fillText("WAVE CLEAR READY", VW / 2 * sx, (VH - 18) * sy);
      }
    }

    /* ── Game loop ── */
    var prev = 0;

    function loop(now) {
      var dt = Math.min((now - prev) / 1000, 0.05);
      prev = now;

      /* ── Update ── */
      if (gameStarted && !gameOver) {
        elapsedTime += dt;

        // Paddle movement (keyboard)
        if (!usePointer) {
          if (keys.ArrowLeft) paddleX -= PADDLE_SPEED * dt;
          if (keys.ArrowRight) paddleX += PADDLE_SPEED * dt;
        }
        paddleX = Math.max(paddleW / 2, Math.min(VW - paddleW / 2, paddleX));

        // Update power-up timers
        if (widenTimer > 0) {
          widenTimer -= dt;
          if (widenTimer <= 0) {
            widenTimer = 0;
            paddleW = PADDLE_W;
          }
        }
        if (shrinkTimer > 0) {
          shrinkTimer -= dt;
          if (shrinkTimer <= 0) {
            shrinkTimer = 0;
            paddleW = PADDLE_W;
          }
        }
        if (burnerTimer > 0) {
          burnerTimer -= dt;
          if (burnerTimer <= 0) {
            burnerTimer = 0;
            for (var bi = 0; bi < balls.length; bi++) {
              balls[bi].burner = false;
            }
          }
        }
        if (freezeTimer > 0) {
          freezeTimer -= dt;
          if (freezeTimer <= 0) freezeTimer = 0;
        }
        if (magnetizeTimer > 0) {
          magnetizeTimer -= dt;
          if (magnetizeTimer <= 0) magnetizeTimer = 0;
        }

        // Process cascade delays
        if (cascadeDelay > 0) {
          cascadeDelay -= dt;
          if (cascadeDelay <= 0) {
            cascadeDelay = 0;
            processCascadePending();
          }
        }

        // Smooth brick slide toward targetY
        for (var si = 0; si < bricks.length; si++) {
          var sb = bricks[si];
          if (!sb.alive || sb.targetY === undefined) continue;
          if (sb.y < sb.targetY) {
            sb.y = Math.min(sb.targetY, sb.y + BRICK_SLIDE_SPEED * dt);
            if (sb.y >= sb.targetY) {
              sb.y = sb.targetY;
              delete sb.targetY;
            }
          }
        }

        // Update flash timers
        for (var fi = 0; fi < bricks.length; fi++) {
          if (bricks[fi].flashTimer > 0) {
            bricks[fi].flashTimer -= dt;
          }
        }

        // Rising tide
        if (elapsedTime > riseStartDelay && freezeTimer <= 0) {
          riseTimer += dt;
          riseInterval = Math.max(4, 12 - (elapsedTime / 60) * 0.8);
          if (riseTimer >= riseInterval) {
            riseTimer = 0;
            spawnRisingRow();
          }
        }

        // Update balls
        for (var i = balls.length - 1; i >= 0; i--) {
          var ball = balls[i];

          if (ball.attached) {
            ball.x = paddleX;
            ball.y = PADDLE_Y - BALL_R;
            continue;
          }

          // Magnetize: curve toward nearest brick cluster
          if (magnetizeTimer > 0) {
            var nearestDist = Infinity;
            var nearestBrick = null;
            for (var mi = 0; mi < bricks.length; mi++) {
              if (!bricks[mi].alive) continue;
              var mdx = (bricks[mi].x + bricks[mi].w / 2) - ball.x;
              var mdy = (bricks[mi].y + bricks[mi].h / 2) - ball.y;
              var md = mdx * mdx + mdy * mdy;
              if (md < nearestDist) {
                nearestDist = md;
                nearestBrick = bricks[mi];
              }
            }
            if (nearestBrick) {
              var tx = (nearestBrick.x + nearestBrick.w / 2) - ball.x;
              var ty = (nearestBrick.y + nearestBrick.h / 2) - ball.y;
              var tLen = Math.sqrt(tx * tx + ty * ty);
              if (tLen > 0) {
                var magStrength = 80;
                ball.vx += (tx / tLen) * magStrength * dt;
                ball.vy += (ty / tLen) * magStrength * dt;
                // Normalize to maintain speed
                var cSpd = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                if (cSpd > 0) {
                  ball.vx = (ball.vx / cSpd) * ball.speed;
                  ball.vy = (ball.vy / cSpd) * ball.speed;
                }
              }
            }
          }

          // Move ball
          ball.x += ball.vx * dt;
          ball.y += ball.vy * dt;

          // Wall bounces
          if (ball.x - BALL_R <= 0) {
            ball.x = BALL_R;
            ball.vx = Math.abs(ball.vx);
          } else if (ball.x + BALL_R >= VW) {
            ball.x = VW - BALL_R;
            ball.vx = -Math.abs(ball.vx);
          }

          if (ball.y - BALL_R <= 0) {
            ball.y = BALL_R;
            ball.vy = Math.abs(ball.vy);
          }

          // Paddle collision
          if (ball.vy > 0 &&
              ball.y + BALL_R >= PADDLE_Y &&
              ball.y + BALL_R <= PADDLE_Y + PADDLE_H + ball.vy * dt &&
              ball.x >= paddleX - paddleW / 2 &&
              ball.x <= paddleX + paddleW / 2) {

            ball.y = PADDLE_Y - BALL_R;
            comboStreak = 0; // Reset combo on paddle contact

            var hitPos = (ball.x - (paddleX - paddleW / 2)) / paddleW;
            var angle = -150 + hitPos * 120;
            var rad = angle * Math.PI / 180;

            if (Math.abs(rad + Math.PI / 2) > (Math.PI / 2 - MIN_BOUNCE_ANGLE)) {
              if (rad > -Math.PI / 2) {
                rad = -(MIN_BOUNCE_ANGLE);
              } else {
                rad = -(Math.PI - MIN_BOUNCE_ANGLE);
              }
            }

            ball.vx = Math.cos(rad) * ball.speed;
            ball.vy = Math.sin(rad) * ball.speed;
          }

          // Brick collisions
          ballBrickCollision(ball);

          // Ball out bottom
          if (ball.y > VH + BALL_R) {
            balls.splice(i, 1);
          }
        }

        // Life lost when all balls gone
        if (balls.length === 0 && !gameOver) {
          lives--;
          if (lives <= 0) {
            triggerGameOver();
          } else {
            paddleW = PADDLE_W;
            widenTimer = 0;
            shrinkTimer = 0;
            attachBall();
          }
        }

        // Update power-ups (fall + catch)
        for (var pi = powerups.length - 1; pi >= 0; pi--) {
          var pu = powerups[pi];
          pu.y += POWERUP_FALL_SPEED * dt;

          if (pu.y + POWERUP_H / 2 >= PADDLE_Y &&
              pu.y - POWERUP_H / 2 <= PADDLE_Y + PADDLE_H &&
              pu.x + POWERUP_W / 2 >= paddleX - paddleW / 2 &&
              pu.x - POWERUP_W / 2 <= paddleX + paddleW / 2) {
            applyPowerup(pu);
            powerups.splice(pi, 1);
            continue;
          }

          if (pu.y > VH + POWERUP_H) {
            powerups.splice(pi, 1);
          }
        }

        // Update falling hazards
        for (var hi = fallingHazards.length - 1; hi >= 0; hi--) {
          var haz = fallingHazards[hi];
          haz.y += HAZARD_FALL_SPEED * dt;

          if (!gameOver &&
              haz.y + haz.h >= PADDLE_Y &&
              haz.y <= PADDLE_Y + PADDLE_H &&
              haz.x + haz.w >= paddleX - paddleW / 2 &&
              haz.x <= paddleX + paddleW / 2) {
            lives--;
            fallingHazards.splice(hi, 1);
            if (lives <= 0 && !gameOver) {
              triggerGameOver();
            }
            continue;
          }

          if (haz.y > VH + haz.h) {
            fallingHazards.splice(hi, 1);
          }
        }

        // Spawn rising bricks
        if (elapsedTime > riseStartDelay) {
          risingBrickTimer -= dt;
          if (risingBrickTimer <= 0) {
            risingBrickTimer = RISING_BRICK_INTERVAL_MIN + Math.random() * (RISING_BRICK_INTERVAL_MAX - RISING_BRICK_INTERVAL_MIN);
            var rbCol = Math.floor(Math.random() * COLS);
            var rbX = GRID_X + rbCol * (BRICK_W + BRICK_GAP_X);
            risingBricks.push({
              x: rbX, y: VH + BRICK_H,
              w: BRICK_W, h: BRICK_H,
              colorKey: COLOR_KEYS[Math.floor(Math.random() * COLOR_KEYS.length)],
              col: rbCol
            });
          }
        }

        // Update rising bricks
        for (var ri = risingBricks.length - 1; ri >= 0; ri--) {
          var rb = risingBricks[ri];
          rb.y -= RISING_BRICK_SPEED * dt;

          // Ball collision — destroy the rising brick
          var rbDestroyed = false;
          for (var rbi = 0; rbi < balls.length; rbi++) {
            var rball = balls[rbi];
            if (rball.attached) continue;
            var rcx = Math.max(rb.x, Math.min(rball.x, rb.x + rb.w));
            var rcy = Math.max(rb.y, Math.min(rball.y, rb.y + rb.h));
            var rdx = rball.x - rcx;
            var rdy = rball.y - rcy;
            if (rdx * rdx + rdy * rdy <= BALL_R * BALL_R) {
              if (!rball.burner) rball.vy = -rball.vy;
              score += 15;
              addDebris(rb);
              risingBricks.splice(ri, 1);
              rbDestroyed = true;
              break;
            }
          }
          if (rbDestroyed) continue;

          // Paddle collision — smash the rising brick
          if (rb.y <= PADDLE_Y + PADDLE_H &&
              rb.y + rb.h >= PADDLE_Y &&
              rb.x + rb.w >= paddleX - paddleW / 2 &&
              rb.x <= paddleX + paddleW / 2) {
            score += 15;
            risingBricks.splice(ri, 1);
            continue;
          }

          // Settle into grid: find bottommost brick in this column
          var settleY = -1;
          var bottomBrickY = -1;
          for (var li = 0; li < bricks.length; li++) {
            if (!bricks[li].alive) continue;
            if (brickGridCol(bricks[li]) !== rb.col) continue;
            if (bricks[li].y > bottomBrickY) bottomBrickY = bricks[li].y;
          }

          if (bottomBrickY >= 0) {
            // Settle one row below the bottommost brick
            var targetY = bottomBrickY + BRICK_H + BRICK_GAP_Y;
            if (rb.y <= targetY) settleY = targetY;
          } else if (rb.y <= GRID_Y) {
            // Empty column — settle at top
            settleY = GRID_Y;
          }

          if (settleY >= 0) {
            // Snap to grid and become a regular brick
            bricks.push({
              x: rb.x, y: settleY, w: BRICK_W, h: BRICK_H,
              type: "normal", hits: 1, maxHits: 1, points: 10,
              colorKey: rb.colorKey, alive: true, hazard: false,
              flashTimer: 0
            });
            risingBricks.splice(ri, 1);

            // Check for cascades from the newly settled brick
            var settledBrick = bricks[bricks.length - 1];
            var sGroup = findConnectedGroup(settledBrick);
            if (sGroup.length >= 3) {
              chainCounter = 1;
              if (chainCounter > longestChain) longestChain = chainCounter;
              for (var sg = 0; sg < sGroup.length; sg++) {
                sGroup[sg].flashTimer = 0.2;
                cascadePending.push(sGroup[sg]);
              }
              cascadeDelay = 0.2;
            }
            continue;
          }

          // Off top of screen — remove
          if (rb.y + rb.h < 0) {
            risingBricks.splice(ri, 1);
          }
        }

        // Update debris junk particles
        for (var di = debrisParticles.length - 1; di >= 0; di--) {
          var dp = debrisParticles[di];
          if (!dp.settled) {
            dp.y += 400 * dt;
            if (dp.y >= dp.targetY) {
              dp.y = dp.targetY;
              dp.settled = true;
            }
          }
        }
      }

      /* ── Render ── */
      ctx.fillStyle = "#08090e";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (gameStarted) {
        drawDangerLine();
        drawBricks();
        drawRisingBricks();
        drawFallingHazards();
        drawPowerups();
        drawPaddle();
        drawBalls();
        drawDebrisJunk();
        drawHUD();

        // Wave clear screen flash
        if (waveClearFlash > 0) {
          waveClearFlash -= dt;
          var flashAlpha = Math.max(0, waveClearFlash / 0.35) * 0.25;
          ctx.fillStyle = "rgba(133,204,255," + flashAlpha + ")";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
      }

      requestAnimationFrame(loop);
    }

    /* ── Build rules dialog dynamically ── */
    function buildRulesDialog() {
      var isDesktop = window.matchMedia("(hover:hover) and (pointer:fine)").matches;

      var html = "";
      if (isDesktop) {
        html += "<div><strong>Mouse:</strong> Move paddle</div>";
        html += "<div><strong>Arrow Keys:</strong> Move paddle</div>";
        html += "<div><strong>Click / Space / D:</strong> Launch ball or Wave Clear</div>";
      } else {
        html += "<div><strong>Drag:</strong> Move paddle</div>";
        html += "<div><strong>Tap:</strong> Launch ball</div>";
        html += "<div><strong>Swipe up:</strong> Wave Clear (when junk pile full)</div>";
      }

      html += '<div style="margin-top:10px;font-size:12px;"><strong>How it works</strong></div>';
      html += '<div style="font-size:12px;">New rows push down from the top. Match 3+ same-color bricks to chain-clear them. Loose bricks fly up from below \u2014 smash them with the paddle or let them settle to build chains!</div>';

      html += '<div style="margin-top:8px;font-size:12px;"><strong>Power-ups</strong></div>';
      html += '<div class="powerup-legend">';
      html += '<div class="powerup-legend-item"><span class="powerup-swatch" style="background:#279ced">W</span> Widen</div>';
      html += '<div class="powerup-legend-item"><span class="powerup-swatch" style="background:#279ced">M</span> Multi</div>';
      html += '<div class="powerup-legend-item"><span class="powerup-swatch" style="background:#c68800">B</span> Burner</div>';
      html += '<div class="powerup-legend-item"><span class="powerup-swatch" style="background:#c68800">X</span> Blast</div>';
      html += '<div class="powerup-legend-item"><span class="powerup-swatch" style="background:#e16788">F</span> Freeze</div>';
      html += '<div class="powerup-legend-item"><span class="powerup-swatch" style="background:#e16788">G</span> Magnet</div>';
      html += '<div class="powerup-legend-item"><span class="powerup-swatch" style="background:#404040">S</span> Shrink</div>';
      html += '</div>';

      html += '<div style="margin-top:8px;font-size:12px;color:var(--dk-shadow);">Blocks marked with \u2717 can fall and damage you.</div>';

      html += '<div class="button-row" style="margin-top:12px">';
      html += '<button class="btn" id="startBtn">OK</button>';
      html += '</div>';

      rulesBody.innerHTML = html;

      document.getElementById("startBtn").addEventListener("click", function () {
        rulesOverlay.classList.add("hidden");
        gameStarted = true;
      });
    }

    /* ── UI buttons ── */
    document.getElementById("playAgainBtn").addEventListener("click", function () {
      resetGame();
    });

    /* ── Initialize ── */
    buildRulesDialog();
    generateBricks();
    attachBall();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
