<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Brick Breaker</title>
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self'">
  <meta name="referrer" content="strict-origin-when-cross-origin">
  <link rel="icon" href="favicon.svg" type="image/svg+xml">
  <link rel="stylesheet" href="css/theme.css">
  <style>
    body {
      overflow: hidden; width: 100vw; height: 100vh;
      background: #1a1f2e;
      cursor: default;
    }

    canvas { display: block; }

    /* Rules dialog overlay */
    .rules-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      z-index: 20;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: default;
    }

    .rules-overlay.hidden { display: none; }

    .rules-dialog {
      background: var(--silver);
      border: 2px solid;
      border-color: var(--white) var(--dk-shadow) var(--dk-shadow) var(--white);
      box-shadow: inset 1px 1px 0 var(--silver), inset -1px -1px 0 var(--shadow);
      width: 320px;
      max-width: 90vw;
    }

    .rules-dialog .window-body { padding: 16px; line-height: 1.6; }

    .powerup-legend {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 4px 12px;
      margin-top: 8px;
      font-size: 12px;
    }

    .powerup-legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .powerup-swatch {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 13px;
      border-radius: 6px;
      color: #fff;
      font-size: 10px;
      font-weight: bold;
      flex-shrink: 0;
    }

    /* Game over overlay */
    .gameover-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      z-index: 20;
      display: none;
      align-items: center;
      justify-content: center;
      cursor: default;
    }

    .gameover-overlay.active { display: flex; }

    .gameover-dialog {
      background: var(--silver);
      border: 2px solid;
      border-color: var(--white) var(--dk-shadow) var(--dk-shadow) var(--white);
      box-shadow: inset 1px 1px 0 var(--silver), inset -1px -1px 0 var(--shadow);
      width: 280px;
      max-width: 90vw;
      text-align: center;
    }

    .gameover-dialog .window-body { padding: 20px; line-height: 1.6; }
    .gameover-dialog .final-score { font-size: 28px; font-weight: bold; margin: 8px 0; }
    .gameover-dialog .final-label { font-size: 13px; color: var(--dk-shadow); }
  </style>
</head>
<body>
  <div class="rules-overlay" id="rulesOverlay">
    <div class="rules-dialog">
      <div class="titlebar">
        <span>Brick Breaker</span>
      </div>
      <div class="window-body" id="rulesBody"></div>
    </div>
  </div>

  <canvas id="gameCanvas"></canvas>

  <div class="gameover-overlay" id="gameoverOverlay">
    <div class="gameover-dialog">
      <div class="titlebar">
        <span id="gameoverTitle">Game Over</span>
      </div>
      <div class="window-body">
        <div class="final-label" id="gameoverLabel">Final Score</div>
        <div class="final-score" id="finalScore">0</div>
        <div class="button-row" style="margin-top:12px;justify-content:center;">
          <button class="btn" id="playAgainBtn">Play Again</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    /* ── Canvas setup ── */
    var canvas = document.getElementById("gameCanvas");
    var ctx = canvas.getContext("2d");

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resize);
    resize();

    /* ── DOM refs ── */
    var rulesOverlay = document.getElementById("rulesOverlay");
    var rulesBody = document.getElementById("rulesBody");
    var gameoverOverlay = document.getElementById("gameoverOverlay");
    var gameoverTitle = document.getElementById("gameoverTitle");
    var gameoverLabel = document.getElementById("gameoverLabel");
    var finalScoreEl = document.getElementById("finalScore");

    /* ── Virtual coordinate system ── */
    var VW = 480;
    var VH = 640;

    function scaleX() { return canvas.width / VW; }
    function scaleY() { return canvas.height / VH; }

    /* ── Daily seed (same layout for everyone each day, replayable) ── */
    function todayKey() {
      var d = new Date();
      return d.getFullYear() + "-" + (d.getMonth() + 1) + "-" + d.getDate();
    }

    /* ── FNV-1a hash ── */
    function fnv(str) {
      var h = 0x811c9dc5;
      for (var i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 0x01000193);
      }
      return h >>> 0;
    }

    /* ── Mulberry32 PRNG ── */
    function mulberry32(seed) {
      var t = seed >>> 0;
      return function () {
        t += 0x6D2B79F5;
        var z = t;
        z = Math.imul(z ^ (z >>> 15), z | 1);
        z ^= z + Math.imul(z ^ (z >>> 7), z | 61);
        return ((z ^ (z >>> 14)) >>> 0) / 4294967296;
      };
    }

    /* ── Constants ── */
    var COLS = 10;
    var ROWS = 8;
    var BRICK_W = 44;
    var BRICK_H = 18;
    var BRICK_GAP_X = 4;
    var BRICK_GAP_Y = 3;
    var GRID_X = 2;
    var GRID_Y = 40;

    var PADDLE_W = 80;
    var PADDLE_H = 12;
    var PADDLE_Y = 600;
    var PADDLE_SPEED = 500;
    var PADDLE_W_MIN = 40;
    var PADDLE_W_MAX = 120;
    var PADDLE_W_GROW = 24;
    var PADDLE_W_SHRINK = 20;

    var BALL_R = 6;
    var BALL_INIT_SPEED = 300;
    var BALL_MAX_SPEED = 480;
    var BALL_SPEED_INC = 1.5;
    var MIN_BOUNCE_ANGLE = 20 * Math.PI / 180;

    var MAX_LIVES = 3;
    var MAX_PARTICLES = 128;

    var POWERUP_W = 24;
    var POWERUP_H = 14;
    var POWERUP_FALL_SPEED = 150;
    var POWERUP_SPAWN_CHANCE = 0.12;
    var POWERUP_TIMER_DURATION = 8;

    var HAZARD_CHANCE = 0.08;
    var HAZARD_FALL_SPEED = 200;

    /* GBC-style muted palette — 4 colors cycling 2 rows each */
    var ROW_COLORS = [
      "#5b8c7a", "#5b8c7a", "#6b7ea0", "#6b7ea0",
      "#c4a882", "#c4a882", "#a87e8a", "#a87e8a"
    ];

    var ROW_DARK = [
      "#3d6655", "#3d6655", "#4a5d7a", "#4a5d7a",
      "#9a7f5f", "#9a7f5f", "#7d5a65", "#7d5a65"
    ];

    var POWERUP_TYPES = [
      { type: "widen",     letter: "W", color: "#5b8c7a" },
      { type: "shrink",    letter: "S", color: "#b05050" },
      { type: "multiball", letter: "M", color: "#6b7ea0" },
      { type: "burner",    letter: "B", color: "#d08030" }
    ];

    /* ── Game state ── */
    var bricks = [];
    var paddleX = VW / 2;
    var paddleW = PADDLE_W;
    var balls = [];
    var score = 0;
    var lives = MAX_LIVES;
    var gameStarted = false;
    var gameOver = false;
    var bricksRemaining = 0;

    var particles = [];
    var paddleFlash = null;
    var powerups = [];
    var fallingHazards = [];

    var widenTimer = 0;
    var shrinkTimer = 0;
    var burnerTimer = 0;

    var usePointer = true;
    var keys = {};

    /* ── Daily seed ── */
    var dailySeed = fnv(todayKey());

    /* ── Ball helpers ── */
    function createBall(x, y, vx, vy, speed, attached) {
      return { x: x, y: y, vx: vx, vy: vy, speed: speed, attached: attached, burner: false };
    }

    function attachBall() {
      balls = [];
      var launchAngle = -90 + (Math.random() * 60 - 30);
      var rad = launchAngle * Math.PI / 180;
      var ball = createBall(
        paddleX,
        PADDLE_Y - BALL_R,
        Math.cos(rad) * BALL_INIT_SPEED,
        Math.sin(rad) * BALL_INIT_SPEED,
        BALL_INIT_SPEED,
        true
      );
      balls.push(ball);
    }

    function launchBalls() {
      if (gameOver) return;
      var launched = false;
      for (var i = 0; i < balls.length; i++) {
        if (balls[i].attached) {
          balls[i].attached = false;
          launched = true;
        }
      }
      return launched;
    }

    /* ── Brick generation ── */
    function generateBricks() {
      var rng = mulberry32(dailySeed);
      bricks = [];
      bricksRemaining = 0;

      for (var r = 0; r < ROWS; r++) {
        for (var c = 0; c < COLS; c++) {
          if (rng() > 0.75) continue;

          var typeRoll = rng();
          var type, hits, points;
          if (typeRoll < 0.10) {
            type = "bonus"; hits = 1; points = 50;
          } else if (typeRoll < 0.35) {
            type = "tough"; hits = 2; points = 25;
          } else {
            type = "normal"; hits = 1; points = 10;
          }

          var hazard = false;
          if (rng() < HAZARD_CHANCE) {
            hazard = true;
          }

          var bx = GRID_X + c * (BRICK_W + BRICK_GAP_X);
          var by = GRID_Y + r * (BRICK_H + BRICK_GAP_Y);

          bricks.push({
            x: bx, y: by, w: BRICK_W, h: BRICK_H,
            type: type, hits: hits, maxHits: hits, points: points,
            row: r, col: c, alive: true, hazard: hazard
          });
          bricksRemaining++;
        }
      }

      // Enforce minimum 20 bricks
      if (bricksRemaining < 20) {
        bricks = [];
        bricksRemaining = 0;
        for (var r2 = 0; r2 < ROWS; r2++) {
          for (var c2 = 0; c2 < COLS; c2++) {
            if (rng() > 0.5) continue;
            var bx2 = GRID_X + c2 * (BRICK_W + BRICK_GAP_X);
            var by2 = GRID_Y + r2 * (BRICK_H + BRICK_GAP_Y);
            bricks.push({
              x: bx2, y: by2, w: BRICK_W, h: BRICK_H,
              type: "normal", hits: 1, maxHits: 1, points: 10,
              row: r2, col: c2, alive: true, hazard: rng() < HAZARD_CHANCE
            });
            bricksRemaining++;
          }
        }
        if (bricksRemaining < 20) {
          bricks = [];
          bricksRemaining = 0;
          for (var r3 = 0; r3 < ROWS; r3++) {
            for (var c3 = 0; c3 < COLS; c3++) {
              var bx3 = GRID_X + c3 * (BRICK_W + BRICK_GAP_X);
              var by3 = GRID_Y + r3 * (BRICK_H + BRICK_GAP_Y);
              bricks.push({
                x: bx3, y: by3, w: BRICK_W, h: BRICK_H,
                type: "normal", hits: 1, maxHits: 1, points: 10,
                row: r3, col: c3, alive: true, hazard: rng() < HAZARD_CHANCE
              });
              bricksRemaining++;
            }
          }
        }
      }
    }

    function resetGame() {
      score = 0;
      lives = MAX_LIVES;
      gameOver = false;
      particles = [];
      paddleFlash = null;
      powerups = [];
      fallingHazards = [];
      widenTimer = 0;
      shrinkTimer = 0;
      burnerTimer = 0;
      paddleW = PADDLE_W;
      paddleX = VW / 2;
      generateBricks();
      attachBall();
      gameoverOverlay.classList.remove("active");
    }

    /* ── Particle system ── */
    function spawnParticles(x, y, color, count) {
      for (var i = 0; i < count; i++) {
        var angle = Math.random() * Math.PI * 2;
        var speed = 80 + Math.random() * 120;
        particles.push({
          x: x, y: y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed - 60,
          life: 0.4,
          maxLife: 0.4,
          color: color
        });
        if (particles.length > MAX_PARTICLES) {
          particles.shift();
        }
      }
    }

    /* ── Power-up spawn ── */
    function trySpawnPowerup(bx, by) {
      if (Math.random() >= POWERUP_SPAWN_CHANCE) return;
      var pick = POWERUP_TYPES[Math.floor(Math.random() * POWERUP_TYPES.length)];
      powerups.push({
        x: bx, y: by,
        type: pick.type,
        color: pick.color,
        letter: pick.letter
      });
    }

    function applyPowerup(pu) {
      if (pu.type === "widen") {
        paddleW = Math.min(PADDLE_W_MAX, paddleW + PADDLE_W_GROW);
        widenTimer = POWERUP_TIMER_DURATION;
        shrinkTimer = 0;
      } else if (pu.type === "shrink") {
        paddleW = Math.max(PADDLE_W_MIN, paddleW - PADDLE_W_SHRINK);
        shrinkTimer = POWERUP_TIMER_DURATION;
        widenTimer = 0;
      } else if (pu.type === "multiball") {
        // Spawn 2 extra balls from first non-attached ball
        var src = null;
        for (var i = 0; i < balls.length; i++) {
          if (!balls[i].attached) { src = balls[i]; break; }
        }
        if (src) {
          var currentSpeed = Math.sqrt(src.vx * src.vx + src.vy * src.vy);
          if (currentSpeed === 0) currentSpeed = src.speed;
          var baseAngle = Math.atan2(src.vy, src.vx);
          var offset = 30 * Math.PI / 180;
          var b1 = createBall(src.x, src.y,
            Math.cos(baseAngle + offset) * currentSpeed,
            Math.sin(baseAngle + offset) * currentSpeed,
            src.speed, false);
          b1.burner = src.burner;
          var b2 = createBall(src.x, src.y,
            Math.cos(baseAngle - offset) * currentSpeed,
            Math.sin(baseAngle - offset) * currentSpeed,
            src.speed, false);
          b2.burner = src.burner;
          balls.push(b1);
          balls.push(b2);
        }
      } else if (pu.type === "burner") {
        burnerTimer = POWERUP_TIMER_DURATION;
        for (var j = 0; j < balls.length; j++) {
          balls[j].burner = true;
        }
      }
    }

    /* ── Input handling ── */
    window.addEventListener("keydown", function (e) {
      if (e.key === "ArrowLeft" || e.key === "ArrowRight") {
        e.preventDefault();
        keys[e.key] = true;
        usePointer = false;
      }
      if (e.key === " " || e.key === "Spacebar") {
        e.preventDefault();
        if (gameStarted && !gameOver) launchBalls();
      }
    });

    window.addEventListener("keyup", function (e) {
      keys[e.key] = false;
    });

    window.addEventListener("pointermove", function (e) {
      if (!gameStarted || gameOver) return;
      usePointer = true;
      var sx = scaleX();
      paddleX = e.clientX / sx;
      paddleX = Math.max(paddleW / 2, Math.min(VW - paddleW / 2, paddleX));
    });

    window.addEventListener("touchmove", function (e) {
      if (!gameStarted || gameOver) return;
      e.preventDefault();
      usePointer = true;
      var sx = scaleX();
      paddleX = e.touches[0].clientX / sx;
      paddleX = Math.max(paddleW / 2, Math.min(VW - paddleW / 2, paddleX));
    }, { passive: false });

    canvas.addEventListener("pointerdown", function (e) {
      if (!gameStarted || gameOver) return;
      usePointer = true;
      var sx = scaleX();
      paddleX = e.clientX / sx;
      paddleX = Math.max(paddleW / 2, Math.min(VW - paddleW / 2, paddleX));
      launchBalls();
    });

    /* ── Collision: ball vs bricks ── */
    function ballBrickCollision(ball) {
      for (var i = 0; i < bricks.length; i++) {
        var b = bricks[i];
        if (!b.alive) continue;

        var closestX = Math.max(b.x, Math.min(ball.x, b.x + b.w));
        var closestY = Math.max(b.y, Math.min(ball.y, b.y + b.h));
        var dx = ball.x - closestX;
        var dy = ball.y - closestY;
        var distSq = dx * dx + dy * dy;

        if (distSq <= BALL_R * BALL_R) {
          if (!ball.burner) {
            // Normal bounce
            var overlapLeft = (ball.x + BALL_R) - b.x;
            var overlapRight = (b.x + b.w) - (ball.x - BALL_R);
            var overlapTop = (ball.y + BALL_R) - b.y;
            var overlapBottom = (b.y + b.h) - (ball.y - BALL_R);
            var minOverlapX = Math.min(overlapLeft, overlapRight);
            var minOverlapY = Math.min(overlapTop, overlapBottom);

            if (Math.abs(minOverlapX - minOverlapY) < 1) {
              ball.vx = -ball.vx;
              ball.vy = -ball.vy;
            } else if (minOverlapX < minOverlapY) {
              ball.vx = -ball.vx;
            } else {
              ball.vy = -ball.vy;
            }
          }

          b.hits--;
          if (b.hits <= 0) {
            b.alive = false;
            bricksRemaining--;
            score += b.points;
            ball.speed = Math.min(BALL_MAX_SPEED, ball.speed + BALL_SPEED_INC);

            // Normalize velocity to new speed
            var currentSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
            if (currentSpeed > 0) {
              ball.vx = (ball.vx / currentSpeed) * ball.speed;
              ball.vy = (ball.vy / currentSpeed) * ball.speed;
            }

            var color = ROW_COLORS[b.row] || "#fff";
            var count = 6 + Math.floor(Math.random() * 3);
            spawnParticles(b.x + b.w / 2, b.y + b.h / 2, color, count);

            // Spawn power-up
            trySpawnPowerup(b.x + b.w / 2, b.y + b.h / 2);

            // Hazard: spawn falling hazard
            if (b.hazard) {
              fallingHazards.push({
                x: b.x, y: b.y, w: b.w, h: b.h, row: b.row
              });
            }
          }

          // Burner ball: don't break — can hit multiple bricks per frame
          if (!ball.burner) break;
        }
      }
    }

    /* ── Rendering ── */
    function drawBricks() {
      var sx = scaleX();
      var sy = scaleY();

      for (var i = 0; i < bricks.length; i++) {
        var b = bricks[i];
        if (!b.alive) continue;

        var rx = b.x * sx;
        var ry = b.y * sy;
        var rw = b.w * sx;
        var rh = b.h * sy;

        var color = ROW_COLORS[b.row] || "#fff";
        var darkColor = ROW_DARK[b.row] || "#888";

        if (b.type === "tough" && b.hits < b.maxHits) {
          color = darkColor;
        }

        // Brick body
        ctx.fillStyle = color;
        ctx.fillRect(rx, ry, rw, rh);

        // Top highlight (1px)
        ctx.fillStyle = "rgba(255,255,255,0.25)";
        ctx.fillRect(rx, ry, rw, 1 * sy);

        // Bottom shadow (1px)
        ctx.fillStyle = "rgba(0,0,0,0.2)";
        ctx.fillRect(rx, ry + rh - 1 * sy, rw, 1 * sy);

        // Tough brick: extra outline
        if (b.type === "tough") {
          ctx.strokeStyle = darkColor;
          ctx.lineWidth = 1;
          ctx.strokeRect(rx + 0.5, ry + 0.5, rw - 1, rh - 1);
        }

        // Tough brick with crack lines
        if (b.type === "tough" && b.hits < b.maxHits) {
          ctx.strokeStyle = "rgba(0,0,0,0.5)";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(rx + rw * 0.3, ry);
          ctx.lineTo(rx + rw * 0.5, ry + rh * 0.5);
          ctx.lineTo(rx + rw * 0.4, ry + rh);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(rx + rw * 0.5, ry + rh * 0.5);
          ctx.lineTo(rx + rw * 0.7, ry + rh * 0.3);
          ctx.stroke();
        }

        // Bonus brick: diamond marker
        if (b.type === "bonus") {
          ctx.fillStyle = "rgba(255,255,255,0.5)";
          var cx = rx + rw / 2;
          var cy = ry + rh / 2;
          var dSize = Math.min(rw, rh) * 0.3;
          ctx.beginPath();
          ctx.moveTo(cx, cy - dSize);
          ctx.lineTo(cx + dSize, cy);
          ctx.lineTo(cx, cy + dSize);
          ctx.lineTo(cx - dSize, cy);
          ctx.closePath();
          ctx.fill();
        }

        // Hazard brick: X marker
        if (b.hazard) {
          ctx.strokeStyle = "rgba(0,0,0,0.4)";
          ctx.lineWidth = 1.5;
          var xPad = rw * 0.3;
          var yPad = rh * 0.2;
          ctx.beginPath();
          ctx.moveTo(rx + xPad, ry + yPad);
          ctx.lineTo(rx + rw - xPad, ry + rh - yPad);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(rx + rw - xPad, ry + yPad);
          ctx.lineTo(rx + xPad, ry + rh - yPad);
          ctx.stroke();
        }
      }
    }

    function drawFallingHazards() {
      var sx = scaleX();
      var sy = scaleY();
      for (var i = 0; i < fallingHazards.length; i++) {
        var h = fallingHazards[i];
        var rx = h.x * sx;
        var ry = h.y * sy;
        var rw = h.w * sx;
        var rh = h.h * sy;

        ctx.globalAlpha = 0.6;
        var color = ROW_COLORS[h.row] || "#888";
        ctx.fillStyle = color;
        ctx.fillRect(rx, ry, rw, rh);

        // Red X
        ctx.strokeStyle = "#c04040";
        ctx.lineWidth = 2;
        var xPad = rw * 0.25;
        var yPad = rh * 0.15;
        ctx.beginPath();
        ctx.moveTo(rx + xPad, ry + yPad);
        ctx.lineTo(rx + rw - xPad, ry + rh - yPad);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(rx + rw - xPad, ry + yPad);
        ctx.lineTo(rx + xPad, ry + rh - yPad);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
    }

    function drawPowerups() {
      var sx = scaleX();
      var sy = scaleY();
      for (var i = 0; i < powerups.length; i++) {
        var pu = powerups[i];
        var rx = pu.x * sx;
        var ry = pu.y * sy;
        var rw = POWERUP_W * sx;
        var rh = POWERUP_H * sy;
        var cr = Math.min(rw, rh) * 0.4;

        // Capsule shape
        ctx.fillStyle = pu.color;
        ctx.beginPath();
        ctx.moveTo(rx - rw / 2 + cr, ry - rh / 2);
        ctx.lineTo(rx + rw / 2 - cr, ry - rh / 2);
        ctx.quadraticCurveTo(rx + rw / 2, ry - rh / 2, rx + rw / 2, ry - rh / 2 + cr);
        ctx.lineTo(rx + rw / 2, ry + rh / 2 - cr);
        ctx.quadraticCurveTo(rx + rw / 2, ry + rh / 2, rx + rw / 2 - cr, ry + rh / 2);
        ctx.lineTo(rx - rw / 2 + cr, ry + rh / 2);
        ctx.quadraticCurveTo(rx - rw / 2, ry + rh / 2, rx - rw / 2, ry + rh / 2 - cr);
        ctx.lineTo(rx - rw / 2, ry - rh / 2 + cr);
        ctx.quadraticCurveTo(rx - rw / 2, ry - rh / 2, rx - rw / 2 + cr, ry - rh / 2);
        ctx.closePath();
        ctx.fill();

        // Letter
        ctx.fillStyle = "#fff";
        ctx.font = "bold " + Math.round(10 * Math.min(sx, sy)) + "px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(pu.letter, rx, ry);
      }
    }

    function drawPaddle() {
      var sx = scaleX();
      var sy = scaleY();
      var px = (paddleX - paddleW / 2) * sx;
      var py = PADDLE_Y * sy;
      var pw = paddleW * sx;
      var ph = PADDLE_H * sy;

      var grad = ctx.createLinearGradient(px, py, px, py + ph);
      grad.addColorStop(0, "#c8e0f8");
      grad.addColorStop(1, "#4a8abe");
      ctx.fillStyle = grad;
      var cr = 3 * sx;
      ctx.beginPath();
      ctx.moveTo(px + cr, py);
      ctx.lineTo(px + pw - cr, py);
      ctx.quadraticCurveTo(px + pw, py, px + pw, py + cr);
      ctx.lineTo(px + pw, py + ph - cr);
      ctx.quadraticCurveTo(px + pw, py + ph, px + pw - cr, py + ph);
      ctx.lineTo(px + cr, py + ph);
      ctx.quadraticCurveTo(px, py + ph, px, py + ph - cr);
      ctx.lineTo(px, py + cr);
      ctx.quadraticCurveTo(px, py, px + cr, py);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = "#1a4a6e";
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    function drawBalls() {
      var sx = scaleX();
      var sy = scaleY();
      for (var i = 0; i < balls.length; i++) {
        var ball = balls[i];
        var bx = ball.x * sx;
        var by = ball.y * sy;
        var br = BALL_R * Math.min(sx, sy);

        var ballColor = ball.burner ? "#ff8c00" : "#fff";
        var glowColor = ball.burner ? "rgba(255,140,0," : "rgba(255,255,255,";

        // Glow
        var glow = ctx.createRadialGradient(bx, by, 0, bx, by, br * 3);
        glow.addColorStop(0, glowColor + "0.15)");
        glow.addColorStop(1, glowColor + "0)");
        ctx.fillStyle = glow;
        ctx.fillRect(bx - br * 3, by - br * 3, br * 6, br * 6);

        // Ball
        ctx.beginPath();
        ctx.arc(bx, by, br, 0, Math.PI * 2);
        ctx.fillStyle = ballColor;
        ctx.fill();
      }
    }

    function drawParticles() {
      var sx = scaleX();
      var sy = scaleY();
      for (var i = 0; i < particles.length; i++) {
        var p = particles[i];
        var alpha = p.life / p.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x * sx - 2, p.y * sy - 2, 4, 4);
      }
      ctx.globalAlpha = 1;
    }

    function drawPaddleFlash() {
      if (!paddleFlash) return;
      var sx = scaleX();
      var sy = scaleY();
      var fx = paddleFlash.x * sx;
      var fy = paddleFlash.y * sy;
      var fr = paddleFlash.radius * Math.min(sx, sy);
      var alpha = paddleFlash.life / paddleFlash.maxLife;

      var grad = ctx.createRadialGradient(fx, fy, 0, fx, fy, fr);
      grad.addColorStop(0, "rgba(255,255,255," + (alpha * 0.6) + ")");
      grad.addColorStop(1, "rgba(255,255,255,0)");
      ctx.fillStyle = grad;
      ctx.fillRect(fx - fr, fy - fr, fr * 2, fr * 2);
    }

    function drawHUD() {
      var sx = scaleX();
      var sy = scaleY();
      var fontSize = Math.round(14 * Math.min(sx, sy));

      // Score — left side
      ctx.fillStyle = "#c8e0f8";
      ctx.font = "bold " + fontSize + "px sans-serif";
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      ctx.fillText("Score: " + score, 8 * sx, 10 * sy);

      // Lives — right side as dots
      var dotR = 5 * Math.min(sx, sy);
      var dotSpacing = 16 * sx;
      var dotY = 18 * sy;
      var startDotX = canvas.width - 12 * sx;

      for (var i = MAX_LIVES - 1; i >= 0; i--) {
        var dotX = startDotX - (MAX_LIVES - 1 - i) * dotSpacing;
        ctx.beginPath();
        ctx.arc(dotX, dotY, dotR, 0, Math.PI * 2);
        if (i < lives) {
          ctx.fillStyle = "#5b8c7a";
        } else {
          ctx.fillStyle = "rgba(91,140,122,0.25)";
        }
        ctx.fill();
      }
    }

    /* ── Game loop ── */
    var prev = 0;

    function loop(now) {
      var dt = Math.min((now - prev) / 1000, 0.05);
      prev = now;

      /* ── Update ── */
      if (gameStarted && !gameOver) {
        // Paddle movement (keyboard)
        if (!usePointer) {
          if (keys.ArrowLeft) paddleX -= PADDLE_SPEED * dt;
          if (keys.ArrowRight) paddleX += PADDLE_SPEED * dt;
        }
        paddleX = Math.max(paddleW / 2, Math.min(VW - paddleW / 2, paddleX));

        // Update power-up timers
        if (widenTimer > 0) {
          widenTimer -= dt;
          if (widenTimer <= 0) {
            widenTimer = 0;
            paddleW = PADDLE_W;
          }
        }
        if (shrinkTimer > 0) {
          shrinkTimer -= dt;
          if (shrinkTimer <= 0) {
            shrinkTimer = 0;
            paddleW = PADDLE_W;
          }
        }
        if (burnerTimer > 0) {
          burnerTimer -= dt;
          if (burnerTimer <= 0) {
            burnerTimer = 0;
            for (var bi = 0; bi < balls.length; bi++) {
              balls[bi].burner = false;
            }
          }
        }

        // Update balls
        for (var i = balls.length - 1; i >= 0; i--) {
          var ball = balls[i];

          if (ball.attached) {
            ball.x = paddleX;
            ball.y = PADDLE_Y - BALL_R;
            continue;
          }

          // Move ball
          ball.x += ball.vx * dt;
          ball.y += ball.vy * dt;

          // Wall bounces
          if (ball.x - BALL_R <= 0) {
            ball.x = BALL_R;
            ball.vx = Math.abs(ball.vx);
          } else if (ball.x + BALL_R >= VW) {
            ball.x = VW - BALL_R;
            ball.vx = -Math.abs(ball.vx);
          }

          if (ball.y - BALL_R <= 0) {
            ball.y = BALL_R;
            ball.vy = Math.abs(ball.vy);
          }

          // Paddle collision
          if (ball.vy > 0 &&
              ball.y + BALL_R >= PADDLE_Y &&
              ball.y + BALL_R <= PADDLE_Y + PADDLE_H + ball.vy * dt &&
              ball.x >= paddleX - paddleW / 2 &&
              ball.x <= paddleX + paddleW / 2) {

            ball.y = PADDLE_Y - BALL_R;

            var hitPos = (ball.x - (paddleX - paddleW / 2)) / paddleW;
            var angle = -150 + hitPos * 120;
            var rad = angle * Math.PI / 180;

            if (Math.abs(rad + Math.PI / 2) > (Math.PI / 2 - MIN_BOUNCE_ANGLE)) {
              if (rad > -Math.PI / 2) {
                rad = -(MIN_BOUNCE_ANGLE);
              } else {
                rad = -(Math.PI - MIN_BOUNCE_ANGLE);
              }
            }

            ball.vx = Math.cos(rad) * ball.speed;
            ball.vy = Math.sin(rad) * ball.speed;

            paddleFlash = {
              x: ball.x, y: PADDLE_Y,
              radius: 20,
              life: 0.15, maxLife: 0.15
            };
          }

          // Brick collisions
          ballBrickCollision(ball);

          // Burner trail particle
          if (ball.burner) {
            spawnParticles(ball.x, ball.y, "#ff8c00", 1);
          }

          // Ball out bottom — splice
          if (ball.y > VH + BALL_R) {
            balls.splice(i, 1);
          }
        }

        // Life lost when all balls gone
        if (balls.length === 0 && !gameOver) {
          lives--;
          if (lives <= 0) {
            gameOver = true;
            gameoverTitle.textContent = "Game Over";
            gameoverLabel.textContent = "Final Score";
            finalScoreEl.textContent = score;
            gameoverOverlay.classList.add("active");
          } else {
            paddleW = PADDLE_W;
            widenTimer = 0;
            shrinkTimer = 0;
            attachBall();
          }
        }

        // Update power-ups (fall + catch)
        for (var pi = powerups.length - 1; pi >= 0; pi--) {
          var pu = powerups[pi];
          pu.y += POWERUP_FALL_SPEED * dt;

          // Check paddle catch
          if (pu.y + POWERUP_H / 2 >= PADDLE_Y &&
              pu.y - POWERUP_H / 2 <= PADDLE_Y + PADDLE_H &&
              pu.x + POWERUP_W / 2 >= paddleX - paddleW / 2 &&
              pu.x - POWERUP_W / 2 <= paddleX + paddleW / 2) {
            applyPowerup(pu);
            powerups.splice(pi, 1);
            continue;
          }

          // Off bottom
          if (pu.y > VH + POWERUP_H) {
            powerups.splice(pi, 1);
          }
        }

        // Update falling hazards
        for (var hi = fallingHazards.length - 1; hi >= 0; hi--) {
          var haz = fallingHazards[hi];
          haz.y += HAZARD_FALL_SPEED * dt;

          // Check paddle collision
          if (!gameOver &&
              haz.y + haz.h >= PADDLE_Y &&
              haz.y <= PADDLE_Y + PADDLE_H &&
              haz.x + haz.w >= paddleX - paddleW / 2 &&
              haz.x <= paddleX + paddleW / 2) {
            // Damage the player
            lives--;
            spawnParticles(paddleX, PADDLE_Y, "#c04040", 10);
            fallingHazards.splice(hi, 1);
            if (lives <= 0 && !gameOver) {
              gameOver = true;
              gameoverTitle.textContent = "Game Over";
              gameoverLabel.textContent = "Final Score";
              finalScoreEl.textContent = score;
              gameoverOverlay.classList.add("active");
            }
            continue;
          }

          // Off bottom
          if (haz.y > VH + haz.h) {
            fallingHazards.splice(hi, 1);
          }
        }

        // Win check
        if (bricksRemaining <= 0 && !gameOver) {
          gameOver = true;
          gameoverTitle.textContent = "You Win!";
          gameoverLabel.textContent = "Final Score";
          finalScoreEl.textContent = score;
          gameoverOverlay.classList.add("active");
        }

        // Update particles
        for (var pi2 = particles.length - 1; pi2 >= 0; pi2--) {
          var p = particles[pi2];
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vy += 200 * dt;
          p.life -= dt;
          if (p.life <= 0) particles.splice(pi2, 1);
        }

        // Update paddle flash
        if (paddleFlash) {
          paddleFlash.life -= dt;
          paddleFlash.radius += 80 * dt;
          if (paddleFlash.life <= 0) paddleFlash = null;
        }
      }

      /* ── Render ── */
      ctx.fillStyle = "#1a1f2e";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (gameStarted) {
        drawBricks();
        drawFallingHazards();
        drawPowerups();
        drawPaddle();
        drawBalls();
        drawParticles();
        drawPaddleFlash();
        drawHUD();
      }

      requestAnimationFrame(loop);
    }

    /* ── Build rules dialog dynamically ── */
    function buildRulesDialog() {
      var isDesktop = window.matchMedia("(hover:hover) and (pointer:fine)").matches;

      var html = "";
      if (isDesktop) {
        html += "<div><strong>Mouse:</strong> Move paddle</div>";
        html += "<div><strong>Arrow Keys:</strong> Move paddle</div>";
        html += "<div><strong>Click / Space:</strong> Launch ball</div>";
      } else {
        html += "<div><strong>Drag:</strong> Move paddle</div>";
        html += "<div><strong>Tap:</strong> Launch ball</div>";
      }

      html += '<div style="margin-top:10px;font-size:12px;"><strong>Power-ups</strong></div>';
      html += '<div class="powerup-legend">';
      html += '<div class="powerup-legend-item"><span class="powerup-swatch" style="background:#5b8c7a">W</span> Widen</div>';
      html += '<div class="powerup-legend-item"><span class="powerup-swatch" style="background:#b05050">S</span> Shrink</div>';
      html += '<div class="powerup-legend-item"><span class="powerup-swatch" style="background:#6b7ea0">M</span> Multiball</div>';
      html += '<div class="powerup-legend-item"><span class="powerup-swatch" style="background:#d08030">B</span> Burner</div>';
      html += '</div>';

      html += '<div style="margin-top:8px;font-size:12px;color:var(--dk-shadow);">Blocks marked with \u2717 can fall and damage you.</div>';

      html += '<div class="button-row" style="margin-top:12px">';
      html += '<button class="btn" id="startBtn">OK</button>';
      html += '</div>';

      rulesBody.innerHTML = html;

      document.getElementById("startBtn").addEventListener("click", function () {
        rulesOverlay.classList.add("hidden");
        gameStarted = true;
      });
    }

    /* ── UI buttons ── */
    document.getElementById("playAgainBtn").addEventListener("click", function () {
      resetGame();
    });

    /* ── Initialize ── */
    buildRulesDialog();
    generateBricks();
    attachBall();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
